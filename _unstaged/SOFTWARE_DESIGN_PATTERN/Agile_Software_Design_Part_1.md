# Part 1. 애자일 개발
## Chapter 1. 애자일 실천방법

과거 소프트웨어 개발은 폭포수 모델 같은 선형적 접근을 주로 사용했음.
하지만 이는 변화하는 요구사항에 유연하게 대응하지 못하고, 프로젝트 후반부에 대규모 수정 비용을 초래함.

### 애자일 연합

> 애자일 소프트웨어 개발 선언문
> * 프로세스와 툴보다 개인과 상호작용이 우선이다.
> * 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.
> * 계약 협상보다 고객 협력이 우선이다.
> * 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

### 프로세스와 툴보다 개인과 상호작용이 우선이다.

뛰어난 팀원: 다른 동료와 함께 조화롭게 일할 수 있는 사람.
상호작용하는 능력은 다듬어지지 않은 프로그래밍 실력보다 더 중요하다.
알맞은 툴은 성공을 위해 매우 중요하지만 과유불급이다.
팀을 구성하는 일은 환경을 구축하는 일보다 더 중요하다.

### 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.

팀은 설계 의사결정의 이유와 시스템을 설명하는 사람이 읽을 수 있는 형태로 된 문서를 만들어야 한다.
문서는 짧고 요약적이어야 한다. 최대 12 ~ 24p로 문서가 포괄적인 설계 원리와 가장 높은 시스템 단계의 구조에 대해서만 논해야 한다.
새로운 팀원과 친밀하게 일해야 한다.
**마틴의 문서화 제1법칙**: *그 필요가 급박하고 중요하지 않다면 아무 문서도 만들지 마라.*

### 계약 협상보다 고객 협력이 우선이다.

성공적인 프로젝트를 위해서는 규칙적으로 자주 고객의 피드백을 받아야 한다.
최선의 계약서는 개발 팀과 고객이 함께 작업하면서 결정하는 것이다.

### 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

계획을 세울 때는 그 계획이 탄력적이고 업무와 기술의 변화에 적응할 준비가 되어 있는지 확인해야 한다.
업무 환경은 변하기 쉽고, 그것은 고객의 요구사항을 변하게 만든다. 그리고 고객은 시스템이 일단 동작하기 시작하는 것을 보면 요구사항을 좀 더 높은 단계로 올리고 싶어 할 것이다. 마지막으로, 프로그래머는 요구사항을 알고 있고 이 요구사항이 변하지 않을 것이라고 확신할 수 있다 해도, 개발하는 데 얼마나 많은 시간이 걸릴지는 잘 예상하지 못한다.
계획은 그저 날짜뿐만이 아니라 모양 자체가 변경된다.
계획 전략은 다음 2주간의 세부적인 계획을 수립하고, 다음 3개월간의 계략적인 계획을, 그 이후로는 아주 대강의 계획을 세우는 것이다.
가까운 시일 내에 수행할 태스크에 대해서만 세부적인 계획을 짠다는 것을 의미한다.

### 원칙

* 우리의 최고 가치는 유용한 소프트웨어의 빠르고 지속적인 공개를 통해 고객을 만족시키는 것이다.
	* 품질과 부분 구현 시스템의 빠른 공개 사이의 강한 관계
		* 첫 공개본에서 기능하는 부분이 적을수록 최종 공개본의 품질이 높아진다.
		* 자주 공개할수록, 최종 품질도 좋았다.
	* 애자일 실천방법은 빨리, 자주 공개하는 것이다. 가능하면 기본적인 시스템을 프로젝트 시작 후 처음 몇 주 안에 공개한다. 그리고 2주마다 기능성을 증가시킨 시스템을 계속 공개하려고 노력한다.
* 개발 후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 우위를 위해 변화를 이용한다.
	* 팀이 시장의 요구를 충족시키기 위해 무엇을 해야 하는 지 좀 더 배웠다 → 요구사항 변경은 긍정적이다.
	* 소프트웨어의 구조를 탄력적으로 유지하기 위해 노력하고, 따라서 요구사항이 변경됐을 때 시스템에 미치는 영향은 최소한의 것이 된다.
* 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라.
* 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다.
* 의욕적인 개인들을 중심으로 프로젝트를 구성해라. 환경과 필요로 하는 지원을 제공하고, 그들이 그 일을 해낼 것이라 믿고 맡겨둬라.
	* 사람이 성공의 가장 중요한 요소
* 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적이고 효과적인 방법은 직접 일대일로 **대화**하는 것이다.
* 개발 중인 소프트웨어가 진척 상황의 일차적 척도다.
	* 진척 상황을 현재 고객의 요구를 충족시키고 있는 소프트웨어의 비율로 측정한다.
* 애자일 프로세스는 **지속 가능한 개발**을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 속도를 유지할 수 있어야 한다.
* 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다.
* 단순성(아직 끝내지 않은 일의 양을 최대화하는 예술)은 필수적이다.
	* 가장 간단하고 가장 고품질의 작업을 오늘 행하고, 내일 문제가 생긴다면 그때 변경 작업을 하는 편이 쉬울 것이라고 확신한다.
* 최고의 아키텍쳐, 요구사항, 그리고 설계는 자기 조직적인 팀에서 나온다.
	* 책임감은 외부로부터 팀원 개개인에게 수여되는 것  X
* 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.

### 효과

* 고객 만족도 향상: 요구사항 변경에 빠르게 대응 가능
* 코드 품질 향상: 지속적 테스트와 리팩토링을 통한 유지보수성 확보
* 팀 생산성 및 사기 향상: 자율성과 협업 강화

### 결론

모든 소프트웨어 개발자와 모든 개발팀의 직업적 목표는 그들의 고용인과 고객에게 가능한 가장 높은 가치를 전달하는 것.
애자일 프로세스: 스크럼(SCRUM), 크리스털(Crystal), 기능 중심 개발(Feature Driven Development), 어댑티브 소프트웨어 개발(ADP: Adaptive Software Development), 익스트림 프로그래밍(XP: Extreme Programming) 등

---

## Chapter 2. 익스트림 프로그래밍 소개
### 익스트림 프로그래밍 실천방법

익스트림 프로그래밍(XP: Extreme Programming): 애자일 방법 중 가장 유명, 단순하면서도 서로 의존적인 실천방법의 집합으로 구성됨.
목표: **품질, 적응성, 협업의 극대화**

### 1. 고객 팀 구성원(고객과 협업)

고객: XP 팀의 고객은 기능 요소를 정의하고 우선순위를 매기는 개인 또는 그룹. XP 프로젝트에서는 고객이 누구든 간에 팀의 멤버이며, 팀에서 일할 수 있다.
고객에게 있어 최선의 상황은 개발자와 같은 공간에서 일하는 것이다. 차선은 고객이 개발자와 100피트 거리 내에서 일하는 것이다.

### 2. 사용자 스토리

프로젝트 일정 계획을 세우기 위해서는 요구사항을 추정할 수 있을 만큼의 정보만 알면 된다.
요구사항의 구체적인 세부 내용은 시간이 지남에 따라 바뀌기 쉽다.
XP를 사용할 때 고객은 같이 합의해서 정한 색인 카드에 몇 개의 단어를 적어 그 대화 내용을 기억한다. 개발자는 고객이 색인 카드에 단어를 적을 때, 고객과의 대화를 바탕으로 추정한 내용을 카드에 기록한다.
사용자 스토리(user story)란 현재 진행 중인 요구사항에 관한 대화의 연상 기호다. 이것은 고객이 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획 툴이다.

### 3. 짧은 반복

보통 **2주 단위** 반복 주기
매 반복(iteration)마다 동작하는 소프트웨어를 제공하고 고객의 피드백을 받음

#### 반복 계획

반복은 보통 2주 단위로 진행됨 → 마이너 공개(minor delivery)임을 뜻함.
반복 계획(iteraion plan)은 개발자가 세운 예산에 따라 고객이 선택한 사용자 스토리의 집합이다.
반복이 시작되면, 고객은 그 반복 동안에는 스토리 정의나 우선순위를 바꾸지 않는다고 동의함.
이 시기 동안, 개발자는 스토리를 자유롭게 태스크에 나눠 넣고 기술적, 업무적으로 가장 합리적인 순서로 그 태스크를 수행해나감.

#### 릴리즈 계획

다음 약 6번의 반복 일정을 정밀하게 표현하는 릴리즈 계획(release plan)을 만듦.
릴리즈: 대개 3개월 동안을 의미, 메이저 공개(major delivery)
릴리즈 계획은 개발자가 제시한 예산에 맞춰 고객이 선택한, 우선 순위가 정해진 ‘사용자 스토리’의 묶음으로 구성됨.

### 4. 인수 테스트

사용자 스토리의 세부 사항은 고객이 명시한 인수 테스트(acceptance test)의 형태로 기록됨. 인수 테스트는 자동적으로, 또 반복적으로 실행될 수 있는 스크립트의 언어의 한 종류로 작성됨.
일단 시스템이 인수 테스트를 통과하면, 통과한 테스트의 본문에 추가되고 다시 실패하는 것이 허용되지 않음.

### 5. 짝 프로그래밍

모든 운영 코드(production code)는 2명이 함께 작성
각 짝의 한 멤버는 코드를 짜고, 한 멤버는 에러와 개선점을 찾음.
짝은 적어도 하루에 한 번 바뀌어서 모든 프로그래머가 매일 서로 다른 두 짝으로서 일할 수 있게 해야 함.
협업 강화, 지식 공유, 결함 감소

### 6. 테스트 주도 개발

모든 운영 코드는 실패하는 단위 테스트를 통과하기 위해 작성됨.
테스트 케이스(test case)와 코드를 작성하는 사이의 간격은 1분 정도로 매우 빠르다.
테스트 케이스의 완성된 본문은 코드와 함께 발전함. 이 테스트는 프로그래머로 하여금 프로그램이 잘 동작하는지 점검할 수 있게 해줌. 만약 어떤 짝이 프로그램을 조금 변경한다면, 바로 테스트해서 아무 문제가 없는지 확인할 수 있음. 이런 방식을 리팩토링(refactoring)을 굉장히 용이하게 함.
코드를 모듈별로 분리해 각각 독립적으로 테스트될 수 있게 해야 함. 이런 방식으로 작성되는 코드 구조는 상호 간섭이 아주 적은데, 객체 지향 설계 원칙은 이런 비간섭화를 구현하는 데 큰 역할을 한다.

### 7. 공동 소유권

모든 팀원이 코드베이스의 어느 부분이든 개선 가능
지식 공유와 유연성 극대화

### 8. 지속적인 통합

프로그래머는 자신의 코드를 체크인(check in)하고 하루에 몇 번씩 그것을 통합함.
규칙: 첫 번째로 체크인한 사람을 우선으로 해 나머지 사람의 코드를 병합함.
XP 팀은 비차단 소스 제어(nonblocking source control) 방식을 사용함. 이것은 다른 사람이 체크아웃(check out) 해간 것에 대한 고려 없이, 프로그래머들이 아무 때나 어떤 모듈이라도 체크아웃하도록 허용한다. 프로그래머가 모듈을 수정하고 난 뒤에 그것을 다시 체크인하려면, 먼저 그 모듈을 체크인한 다른 사람이 수정한 부분과 병합할 준비가 되어 있어야 할 것이다.
짝(pair)은 한두 시간 동안 한 태스크에 매달려 테스트 케이스와 운영 코드를 작성함. 그 후 테스트 진행하고 체크인 시도.

### 9. 지속 가능한 속도

소프트웨어 프로젝트는 마라톤이다.
팀은 일정한 속도를 유지
XP 규칙은 팀이 초과 근무를 하지 않도록 해야 한다. 이 규칙의 유일한 예외는 릴리즈의 마지막 주다. 릴리즈라는 골에서 아주 가까운 거리에 있고 종점을 향해 전력 질주를 할 수 있다면, 초과 근무도 무방하다.

### 10. 열린 작업 공간

팀은 열린 공간에서 함께 일한다. 2~4개의 워크스테이션이 설치된 테이블이 있고, 각 워크스테이션에는 짝이 나란히 앉을 수 있도록 2개의 의자가 있다. 벽에는 상황 차트, 태스크 명세(task breakdowns), UML 다이어그램 등이 펼쳐져 있다.

### 11. 계획 세우기 게임

계획 세우기 게임의 정수는 업무와 개발의 책임 분리에 있다. 업무 관련 인력(고객)은 기능 요소가 얼마나 중요한지를 결정하고, 개발자는 그 기능 요소를 구현하는 데 얼마나 비용이 들 것인지를 결정한다.
각 릴리즈와 반복을 시작할 때, 개발자는 가장 최근의 반복이나 릴리즈에서 완성할 수 있었던 양을 기준으로 예산을 세워 고객에게 제출한다. 고객은 총비용의 합이 예산을 넘지 않는 정도로 스토리를 선택함.

### 12. 단순한 설계

XP 팀은 그들의 설계를 가능한 한 단순하고 표현적으로 만든다. 현재 반복에서 작업하기로 계획했던 스토리에만 초점을 맞추어 공략한다. 한 반복에서 다음 반복으로 넘어갈 때 시스템의 설계를 마이그레이션해서, 시스템이 현재 구현하고 있는 스토리에 가장 적합한 설계가 되도록 한다.
XP 팀이 기반구조(infrastructure)을 이용해 시작하지 않을 것임을 의미함. 팀의 첫 번째 행동은 가능한 한 가장 단순한 방식으로 동작하는 스토리의 첫 묶음을 얻어내는 것이 될 것이다.

세 가지 XP 지침
#### 어떻게든 동작하는 가장 단순한 것을 생각한다.

XP 팀은 항상 현재의 스토리 묶음에 적용할 수 있는 가장 간단한 설계 옵션을 찾으려고 함.

#### 필요하지 않을 것이라는 가정에서 시작한다.

XP 팀은 확실히 필요해지기 전에 기반구조를 추가하고 싶은 유혹에 저항하지 않을 때 무슨 일이 일어날 것인지 심각하게 고려함. 즉, 기반구조가 필요하지 않을 것이라는 가정하에 프로젝트를 시작함. 비용 적인 효과가 발생한다는 근거가 있을 때 기반구조를 추가함.

#### 코드를 중복해서 쓰지 않는다.

XP를 수행하는 사람은 코드 중복을 허용하지 않으며, 중복 코드가 발견될 때마다 이를 제거함.
함수로 바꾸거나 템플릿 메소드(template method) 패턴을 상용함.
중복성(redundancy)을 제거하는 최선의 방법은 추상화(abstraction)다.
중복성을 제거하기 위해 팀은 많은 추상형을 만들고 그 결과 결합도(coupling)가 낮아짐.

### 13. 리팩토링

리팩토링은 행위에 영향을 주지 않고 시스템의 구조를 개선하는 일련의 작은 변환을 만드는 방식이다. → 가독성과 유지보수성 확보
각각의 작은 변환이 끝나고 나면, 아무 문제도 없음을 확인하기 위해 단위 테스트를 실시함. 그리고 각 변환 끝에 테스트를 실시하면서 다음 변환을 계속 수행함.
리팩토링은 프로젝트나 릴리즈, 반복, 심지어 일과가 끝날 때도 계속 수행됨. 프로그래머는 1시간 혹은 30분마다 리팩토링을 함.

### 14. 메타포

메타포(metaphor)는 전체 시스템을 하나로 묶는 큰 그림이다. 이것은 모든 개별적인 모듈의 위치와 형태를 명백하게 만드는 시스템의 비전(vision)이다. 모듈의 형태가 메타포와 일치하지 않는다면 그 모듈이 잘못되었음을 알 수 있다.
메타포는 시스템을 이름으로 요약하는데, 이 이름은 시스템의 요소에 기호를 부여하고 그 관계를 정의하는 것을 도와줌.
시스템 구조와 모듈 관계를 이해시키는 공통 비유(메타포)를 사용

### 결론

익스트림 프로그래밍은 애자일 개발 프로세스를 구성하는 단순하고 구체적인 방식의 집합이다.
XP는 소프트웨어 개발을 위한 범용 방식이다.

---

## Chapter 3. 계획 세우기

XP에서의 계획은 고객과 개발자가 함께 사용자 스토리를 정의하고, 이를 반복적으로 세분화/우선순위화하면서 프로젝트를 이끌어가는 과정이다.
중요한 점은 계획은 한 번 정하고 끝나는 것이 아니라, 프로젝트 전반에서 지속적으로 보완되는 활동이라는 것이다.

### (1) 초기 탐색 (Initial Exploration)

- 프로젝트 시작 시 고객과 개발자가 주요 **사용자 스토리(user stories)** 를 도출한다.
- 새로운 스토리는 프로젝트 도중에도 계속 추가될 수 있다.
- 개발자는 각 스토리에 대해 상대적 **비용(점수) 추정**을 제공한다.

### (2) 스파이킹, 분할, 속도 (Spiking, Splitting, Velocity)

- 스토리가 너무 크면 쪼개고(split), 너무 작으면 합쳐서 관리한다.
	- 스토리가 분할되거나 합쳐지면, 다시 추정해야 한다.
	- 스토리를 분할하거나 합치는 주된 이유는 정확한 추정을 할 수 있을 정도의 크기로 만들기 위해서다.
	- 스토리의 정확한 크기를 알기 위해서는 속도라는 요소가 필요하다.
- 초기 **프로토타입(spike solution)** 을 통해 대략적인 속도(velocity: 단위 기간에 처리 가능한 스토리 포인트 양)를 측정할 수 있다.
- 이런 프로토타입 단계를 **스파이크(spike)** 라고 한다.

### (3) 릴리즈 계획 (Release Planning)

- 고객은 주어진 속도를 기준으로 스토리의 **비즈니스 가치와 비용**을 평가하여 우선순위를 정한다.
	- 중요하지만 비용이 비싼 것은, 덜 중요하지만 비용이 훨씬 싼 것을 위해 처리를 미뤄야 한다. 이런 선택이 업무 의사결정이다.
	- 비용 대비 효과가 가장 큰 스토리를 선택한다.
- 릴리즈 시점은 보통 **2~4개월 후**를 기준으로 설정한다.
	- 고객은 그 릴리즈에 구현되었으면 하는 스토리와 대략적인 구현 순서를 선택한다.

### (4) 반복 계획 세우기 (Iteration Planning)

- 한 이터레이션(2주 내외)마다 고객과 개발자가 현재 속도에 맞추어 구현할 스토리를 선택한다.
- 개발자는 구현 순서를 정하고, **반복이 시작되면 스토리에 변경을 허용하지 않는다**.
	- 개발자는 기술적으로 가장 합리적인 순서에 따라 스토리를 구현한다.
	- 모든 스토리 구현이 완료되지 않은 경우에도 반복은 정해진 날짜에 끝난다.
	- 완료한 스토리의 추정 소요 시간을 모두 더하여, 반복의 속도를 계산한다.

### (5) 태스크 계획 (Task Planning)

* 태스크는 한 개발자가 4~16시간 동안 구현할 수 있는 것이다.
- 선택된 스토리를 더 작은 **태스크 단위**로 분해한다.
- 각 태스크는 점수화되며, 개발자들이 협업하여 유연하게 분담한다.
	- 개발자가 전체 프로젝트에 대해 더 알게 될수록, 프로젝트 팀은 더욱 탄탄해지고 더 많은 정보를 알게 된다.
	- 각 개발자는 가장 최근의 반복에서 자신이 어떻게든 구현했던 태스크 포인트가 몇 개인지 알고 있다. 이 숫자는 그들의 개인적인 예산이며, 어떤 팀원도 자신의 예산보다 더 많은 포인트에 참여하지 않는다.
	- 태스크 선택 과정은 모든 태스크가 할당되거나 모든 개발자가 그들의 예산을 다 사용할 때까지 계속된다.
- 만약 태스크가 수행 불가하면 고객에게 다시 우선순위 조정이나 제거를 요청한다

### 반환점

* 반복이 반쯤 진행됐을 때, 팀은 미팅을 갖는다.
	* 계획한 스토리의 반 정도가 완료되어야 한다.
* 반복이 끝날 때 모든 스토리가 완료되도록 재분배 방법을 찾고, 못 찾을 경우 고객에게 보고한다.
* 고객은 반복에서 어떤 태스크나 스토리를 제외할 것인지를 결정할 수 있다.

### 반복

* 각 반복(2주)의 마지막에는 현재 동작하는 실행 가능한 부분을 고객 앞에서 시연한다.
* 고객은 시연된 프로젝트를 통해 외관, 느낌, 성능을 평가해야 하고, 새로운 사용자 스토리를 통해 피드백을 제공한다.
* 고객은 진행 상황을 수시로 알 수 있으며, 속도도 측정할 수 있다.

### 3. 의미와 특징

- **계획의 목적**은 예측이 아니라 **협업과 적응**이다.
- 전통적 계획(상세 일정·문서화 중심)과 달리, XP의 계획은 **고객과 개발자가 함께 의사결정을 내리는 참여형 활동**이다.
- **속도(velocity)** 개념이 있어, 추정과 실제 진행 상황 간의 차이를 줄여 나가며 점점 더 정확해진다.
- 최소의 비용으로 최대의 사업상 가치를 얻을 수 있도록 팀을 제어할 수 있다.

---

## Chapter 4. 테스트 주도 개발
### 1. 테스트의 목적

- 테스트는 단순히 **버그 검출**이나 **검증(verification)** 에만 그치지 않는다.
- XP(익스트림 프로그래밍)에서는 테스트가 **설계와 개발 과정의 중심**에 놓인다.
- 테스트를 통해 코드가 올바르게 동작함을 확인할 뿐 아니라, **설계 결정을 검증하고 코드 개선(리팩토링)을 안전하게 뒷받침**한다 .

### 2. 테스트 주도 개발 (TDD: Test-Driven Development)

* 포괄적인 테스트 집합의 존재에서 이끌어낼 수 있는 이점
	* 프로그램의 모든 단일 함수가 그 동작을 검증하는 테스트를 갖게 된다.
	* 테스트를 먼저 작성할 경우, 프로그래머가 다른 관점에서 문제를 해결할 수 있다.
		* 프로그래머는 작성할 프로그램을 그 프로그램의 호출자 관점에서 봐야 한다.
	* 프로그래머는 자신이 반드시 테스트 가능한 프로그램을 설계하도록 강제할 수 있다.
		* 테스트를 먼저 작성한다는 건 프로그래머가 소프트웨어를 다른 환경과 분리하도록 강제하는 것이다.
	* 테스트가 문서화의 귀중한 한 형태로 기능할 수 있다.
- **실패하는 테스트를 먼저 작성**한 후, 이 테스트를 통과하는 최소한의 코드를 작성한다.
- 그 다음 **리팩토링**으로 코드를 정리하고 개선한다.
- 이 과정을 반복함으로써 코드는 점차 **견고하고 깔끔한 구조**를 갖게 된다.

### 테스트 우선 방식 설계의 예

* 계획된 프로그래밍(intentional programming): 프로그래머는 자신의 의도를 구현하기 전에, 먼저 그 의도를 가능한 한 단순하고 읽기 편하게 만들어 테스트로 제시한다.
* 테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.
* 테스트는 프로그램이 동작하는 방식을 말해준다.
* 테스트는 프로그램을 설명하는 컴파일 가능하고 실행 가능한 문서가 된다.

### 테스트 분리

* 운영 코드를 만들기 전에 테스트를 먼저 작성할 경우, 소프트웨어에서 분리해야 할 부분이 드러나곤 한다.
* 의사 객체(MOCK OBJECT) 패턴을 이용하는 것이다.

### 운 좋게 얻은 분리

* 코드보다 테스트를 먼저 작성하면 설계가 개선된다.
	* 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.

### 3. 인수 테스트 (Acceptance Tests)

* 단위 테스트는 시스템의 작은 구성 요소가 기대한 대로 동작하는지 여부는 검증하지만, 시스템이 전체로서 제대로 작동하는지는 검증하지는 않음. → 필수적 but, 검증툴로서는 불충분
* 단위 테스트는 시스템의 개별적인 메커니즘을 검증하는 화이트박스 테스트
* 인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 블랙박스 테스트
	* 특별한 스크립트 언어로 작성됨
	* 기능 요소의 궁극적인 문서화 형태임
	* 시스템의 기능 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행함.
- 각 사용자 스토리는 반드시 **인수 테스트**로 표현된다.
- 인수 테스트는 **고객 요구사항 충족 여부**를 자동으로 검증하는 역할을 한다.
- 즉, 단위 테스트는 개발자가 코드를 위한 것이고, 인수 테스트는 고객이 기능을 확인하는 기준이다.

### 4. 테스트의 가치

* 테스트 실행이 간단함 → 테스트를 좀 더 자주 실행함 → 테스트에 어긋나는 것들을 좀 더 빨리 찾게 됨
- **설계 가이드**: 테스트는 개발자가 코드의 사용법을 먼저 생각하도록 하여, 더 나은 설계를 유도한다.
- **문서화**: 테스트 코드는 살아 있는 문서로 기능을 설명한다.
	- 단위 테스트와 인수 테스트 모두 컴파일 및 실행 가능한 문서화의 한 형태 → 정확하고 신뢰성이 있다
	- 모호하지 않은 언어로 작성됨
- **회귀 방지**: 기존 기능이 깨지지 않음을 자동으로 확인해준다.
- **변화 수용**: 새로운 요구사항을 추가할 때도, 기존 테스트가 안전망 역할을 한다.

### 5. 애자일과 테스트

- 애자일 개발에서 테스트는 단순히 품질 보증(QA)이 아니라, **개발 프로세스의 핵심 활동**이다.
- “테스트를 작성하지 않으면, 기능을 완전히 구현했다고 말할 수 없다”는 철학을 따른다.

---

## Chapter 5. 리팩토링
### 1. 리팩토링의 정의와 필요성

- **정의:** 마틴 파울러(Martin Fowler)의 정의에 따르면, 리팩토링은 **외부 동작(기능)을 바꾸지 않고 코드의 내부 구조를 개선하는 것**이다. **소프트웨어 시스템을 변경하는 프로세스**
- 단순히 “코드가 잘 돌아가니 됐다”라는 사고방식이 아니라, 코드가 **읽기 쉽고 변경하기 쉬워야 한다**는 점을 강조한다.
- 소프트웨어 모듈의 3대 기능:
    1. **동작**: 작업을 실행한다.
    2. **변경**: 변경을 수용할 수 있다.
    3. **의사소통**: 개발자와 의사소통한다.
- 모듈이 변경이나 의사소통에 실패한다면 리팩토링이 필요하다.
* IntelliJ IDEA 리팩토링 브라우저

```java
private static int calcMaxPrimeFactor() {
	// p가 소수일 때, p의 모든 배수를 지운다
	// 따라서 지워지는 모든 배수는 인수로 p와 q를 갖는다.
	// 'p > 배열 크기의 aqrt(제곱근)'일 경우, q는 1보다 클 수 없다.
	// 따라서 p는 이 배열의 가장 큰 소인수이고,
	// 루프 횟수의 한계 값이기도 하다.
	double maxPrimeFactor = Math.sqrt(isCrossed.length) + 1;
	return (int) maxPrimeFactor;
}
```

### 2. 리팩토링의 목적

- **코드 가독성 향상**: 명확한 변수명, 단순화된 구조.
- **변경 용이성 확보**: 새로운 요구사항을 쉽게 반영할 수 있도록 코드 유연성을 높임.
- **중복 제거와 일관성 유지**: 같은 로직을 하나의 모듈로 통합.
- **지속 가능한 개발**: 기술 부채를 줄이고, 장기 유지보수성을 확보.

### 3. 리팩토링 과정

- **TDD와 결합**: 테스트가 안전망 역할을 하므로 안심하고 구조를 바꿀 수 있음.
- **단계적 개선**: 한 번에 큰 변화를 주는 것이 아니라, 작은 단계를 거쳐 코드 품질을 점진적으로 향상시킴.
- **예제**: 소수 판별 알고리즘을 점진적으로 개선하며 성능과 가독성을 동시에 확보하는 과정을 설명.

#### 4. 리팩토링의 효과

- 코드는 더 간결해지고, 읽기 쉬워짐.
- 유지보수 시 버그 발생 가능성을 줄임.
- **비유:** 리팩토링은 주방 청소와 같다. 한 번 해치우는 게 아니라, 지속적으로 관리해야 쾌적하고 효율적으로 유지된다.

##### 5. 핵심 교훈

- 리팩토링은 선택 사항이 아니라 **지속 가능한 소프트웨어 개발의 필수 요소**다.
- 코드를 단순히 “돌아가게 만드는 것”에서 끝내지 말고, **사람이 읽고 바꿀 수 있는 코드**로 만들어야 한다.
- 원칙·패턴만으로는 부족하고, 개발자의 **훈련·규율·코드 미학에 대한 감각**이 필요하다.

---

## Chapter 6. 프로그래밍 에피소드
#### 1. 목적

- 앞서 다룬 애자일 핵심 기법들(테스트, 리팩토링, 계획)을 실제 코딩 과정에서 **어떻게 적용하는지** 보여주기 위해 **실제 프로그래밍 사례**를 다룸.
- 주제: **볼링 점수 계산 프로그램** 개발.

#### 2. 개발 시나리오

- 두 명의 프로그래머(저자 Bob Martin과 Bob Koss)가 **페어 프로그래밍**을 통해 문제를 해결.
- 요구사항:
    - 각 투구(throw)에서 쓰러뜨린 핀 수를 기록.
    - 스트라이크, 스페어, 일반 점수 규칙을 적용해 최종 점수를 계산.
    - 게임 단위로 점수를 집계.

#### 3. 개발 과정
##### (1) 사용자 스토리 정의

- **사용자 스토리**: “볼링 게임의 점수를 계산할 수 있어야 한다.”
- 이를 더 세분화: 한 게임, 여러 프레임, 스트라이크/스페어 처리 등.

##### (2) 테스트 주도 개발 (TDD)

- 항상 **실패하는 테스트를 먼저 작성** → 해당 기능을 구현 → **테스트 통과 후 리팩토링**.
- 예시 흐름:
    1. `Game` 클래스에 `roll()` 메서드(투구 기록)와 `score()` 메서드(총점 계산)를 정의.
    2. 단순한 케이스(예: 모두 0점)부터 테스트 작성.
    3. 점차 스트라이크, 스페어와 같은 복잡한 규칙으로 확장.

##### (3) 리팩토링

- 구현이 복잡해질 때마다 **메서드 추출**, **변수 이름 개선**, **중복 제거**를 통해 구조 개선.
- 점수 계산 로직을 `Scorer` 클래스로 분리하여 **단일 책임 원칙(SRP)**을 적용.

##### (4) 페어 프로그래밍 협업

- 한 명은 **드라이버(driver)**로 실제 코드를 작성, 다른 한 명은 **내비게이터(navigator)**로 설계와 개선 방향을 제안.
- 이 과정에서 계속 토론하며 코드 품질을 높임.

#### 4. 결과

- 완성된 프로그램은 **모든 점수 규칙을 처리**하면서도,
    - 테스트가 전체 기능을 보장하는 안전망 역할.
    - 리팩토링을 통해 코드가 간결하고 유지보수하기 쉬움.
- **애자일 개발 실천법(XP 기법)**이 실제로 어떻게 작동하는지 보여주는 대표 사례.

#### 5. 요약

- **테스트 주도 개발(TDD)**: 기능 개발 전에 테스트를 작성하면 설계가 단순해지고 안정성이 확보된다.
- **리팩토링**: 깨끗한 코드 유지를 위해 필수적이다.
- **페어 프로그래밍**: 두 명이 협력함으로써 코드 품질과 지식 공유가 강화된다.
- **애자일 실천법의 통합 효과**: 계획, 테스트, 리팩토링, 협업이 유기적으로 작동하여 안정적이고 유연한 개발 가능.