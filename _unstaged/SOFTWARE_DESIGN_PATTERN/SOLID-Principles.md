# 객체지향 설계의 5대 원칙(SOLID Principles) 
## 1. 단일 책임 원칙 (Single Responsibility, SR)
### 1.1. 정의

- **단일 책임 원칙**: 클래스는 **오직 하나의 변경 이유**만 가져야 한다.

### 1.2. 배경

- **응집도(cohesion)**: 모듈 요소들이 수행 목적상 얼마나 밀접하게 관련되는지의 정도. SRP는 응집도를 “변경을 유발하는 힘”과 연결한다.
- **이유**: 요구사항 변화는 **책임 변화**로 나타난다 → 한 클래스에 서로 다른 이유의 책임이 섞이면 변경 파급이 커진다(취약성).
- **위반 결과**: 예측하기 어려운 **추이적 의존성**이 생겨 시스템이 **깨지기 쉬워짐**(fragility).

### 1.3. 책임(Responsibility)의 의미

- 책임은 **하나의 목적을 위한 더 큰 기능 묶음**이며, **변경의 이유**로 정의된다. 클래스에 변경 동기가 **둘 이상** 떠오르면 책임도 둘 이상이다.

### 1.4. 적용과 절충

- 책임 분리는 **항상 클래스 분할**로만 해결되지 않을 수 있다. 이때 **인터페이스 분리**로 두 책임을 분리해 나머지 애플리케이션과의 결합을 낮춘다(예: `Modem`의 연결/전송 인터페이스 분리).
- **과용 금지**: 변화 예측은 어렵다. **증상(symptom)** 이 없는데 무리하게 SRP를 적용하면 **불필요한 복잡도**만 늘어난다.

### 1.5. 결론

- SRP는 가장 단순하지만 **제대로 해내기 가장 어려운 원칙**이다. 실제 설계의 상당 부분은 **책임을 찾아 분리**하는 일이다.

### 1.6. 체크리스트

-  이 클래스(모듈)의 **변경 이유가 둘 이상**인가? → 책임 분리.
-  서로 **다른 이유의 변경**이 한 클래스에 섞여 있는가? → 결합 해소.
-  물리적 분할이 어렵다면 **인터페이스 분리**로 영향 범위를 축소했는가?

## 2. 개방/폐쇄 원칙 (Open/Closed, OC)
### 2.1. 정의

- **“확장에는 열려 있고, 수정에는 닫혀 있어야 한다.”** 재사용 가능한 클래스는 새 요구를 **확장**으로 수용하고, 기존 코드는 **수정**하지 않도록 설계한다.

### 2.2. 배경

- 소프트웨어는 생애주기 동안 **변화**한다. 우리가 원하는 것은 **모듈을 수정하지 않고도 확장**할 수 있는 구조다(확장에 열림 / 수정에 닫힘).
- 이를 위한 수단(도구): **추상화·캡슐화·상속·다형성**, 그리고 **DIP(메커니즘) / LSP(보험)**.

### 2.3. 기본 아이디어

- **구체 클래스에 대한 직접 의존**을 피하고, **추상(인터페이스/추상클래스)** 과 **다형성**으로 결합을 낮춘다.
- ~~클라이언트는 서버의 **인터페이스만** 안다.~~

### 2.4. 예시(도형 그리기)

- 나쁜 설계: `switch(type)`/RTTI로 분기하며 도형별 `Draw*` 호출 → 새 도형 추가 때 **분기문 수정**이 필수 → OCP 위반.
- 좋은 설계: `Shape`에 `draw()`를 두고 **다형성 호출** → 새 도형은 **클래스 추가**만으로 동작.
- 주의: **RTTI/type switch는 위험**—상속 체계 확장 때마다 분기 수정이 발생한다.

### 2.5. 전략적 폐쇄(Strategic Closure)

- **100% 폐쇄는 불가능**하므로 **전략적으로** 폐쇄 대상을 고른다(R. Martin).
    - **추상화로 명시적 폐쇄**: 정책 결정을 **동적 바인딩**/추상 조상 클래스로 이동.
    - **데이터 주도**: 변하기 쉬운 정책을 **별도 위치(파일/객체)** 에 모아 클라이언트를 정책 변경으로부터 닫아둔다.

### 2.6. 휴리스틱

- **어떤 변화에 닫을지**는 맥락에 의존한다. 명백한 변화축부터 적용하라.
- **한 번 당한 변화는 또 온다**: 해당 변화가 처음 발생했을 때 OCP를 적용하라.
- **초기 변화 유도**: TDD/빠른 피드백으로 설계를 일찍 검증·개선하라.

### 2.7. 결론

- OCP 준수는 **유연성/재사용성/유지보수성**을 크게 높인다. 다만 **언어 자체만으로 달성되지 않으며**, 맥락에 맞는 **자연스러운 추상화 구조**를 찾아 변동성을 분리해야 한다. 어디에 적용/미적용할지 **선별**하라.

### 2.8. 체크리스트

-  새 요구 수용 시 **기존 클래스 수정 없이** 확장 가능한가? (플러그인/전략/정책 객체)
-  **인터페이스/추상**을 통해 다형성으로 호출하고 있는가? (구체 의존 제거)
-  **RTTI/분기(switch/if-else)** 없이 동작하는가? (분기 추가가 필요하면 OCP 의심)
-  변하기 쉬운 **정책/규칙**이 한 곳으로 모여 있고, 클라이언트는 그로부터 **닫혀** 있는가?

## 3. 리스코프 치환 원칙 (Liskov Substitution, LS)

- **정의(비공식)**: “파생(하위) 타입의 인스턴스는 언제나 그 상위 타입의 인스턴스를 **대신**할 수 있어야 한다.”
- **정의(공식)**: 모든 프로그램 P가 상위 타입 T로 정의되었을 때, T의 객체 o2를 S의 객체 o1로 바꿔도 P의 **행동이 변하지 않으면** S는 T의 서브타입이다.

### 3.1. 핵심 의미

- **대체 가능성(Substitutability)**: 어떤 코드가 상위 타입의 메서드를 합법적으로 호출할 수 있다면, **그 하위 타입을 그대로 끼워 넣어도** 코드 수정 없이 동작해야 한다.
- **OCP/DIP와의 관계**: OCP가 **목표**, DIP가 **메커니즘**, LSP는 DIP의 **보험(보증)** 역할을 한다. 즉, 상위 정책에 대한 계약을 지켜야 추상화에 의존하는 구조가 무너지지 않는다.

### 3.2. 계약(Design by Contract) 규칙

- 하위 타입이 메서드를 재정의할 때는 **사전조건은 약하게**, **사후조건은 강하게**만 변경 가능하다. (사전조건 약화=제약 일부 제거, 사후조건 강화=제약 유지+추가 허용)

### 3.3. 대표 예시: Rectangle–Square

- 직사각형 사용자 기대: `SetWidth`는 **너비만**, `SetHeight`는 **높이만** 바꾼다(계약). 정사각형이 이를 상속받아 둘 중 하나를 바꿀 때 **둘 다** 바꾸면 계약을 위반한다 → **LSP 위반**.
- 타입 점검/캐스팅(RTTI)으로 분기해 “정사각형이면 예외 처리” 같은 방식은 **OCP 위반**을 유발한다.
- 실제 실패 예: `g(Rectangle r)`가 폭 5, 높이 4 설정 후 면적 20을 기대하는데, `Square` 대입 시 계약 불일치로 실패.

### 3.4. 휴리스틱

- 하위에서 상위 메서드를 **무의미하게 비활성(빈 구현)** 하는 Override는 LSP 위반 신호.
- **의미/목적을 명확히 문서화**하고(암묵적 계약 방지) 테스트로 계약을 고정한다.
- **요약 결론**: LSP가 보장되어야 상위 타입 기준으로 작성된 모듈을 **수정 없이 확장** 가능(OCP 실현)하다.

### 3.5. 체크리스트

-  하위 타입이 상위 타입의 **사전조건을 강화**하거나 **사후조건을 약화**하지 않는가?
-  상위 타입의 **불변식/의미**를 하위 타입이 유지하는가? (대체해도 행동 동일)
-  타입 분기(RTTI/switch) 없이 **다형성**만으로 동작하는가? (OCP 보전)

## 4. 인터페이스 분리 원칙 (Interface Segregation, IS)
### 4.1. 정의

- “한 클래스가 다른 클래스에 의존할 때, 그 의존은 **가능한 가장 작은 인터페이스**에 대해서만 하도록 하라.”

### 4.2. 핵심 아이디어

- **사용자 관점에서 인터페이스 설계**(provider 중심 아님).
- **범용(fat) 인터페이스 대신, 클라이언트별 미세한 인터페이스 다수**가 더 낫다(비응집적 메서드 집합 금지).

### 4.3. 기대 효과(결과)

- 인터페이스가 **작을수록 변경 파급**이 줄고, **변경 발생 가능성**도 낮아진다.
- **다른 클라이언트의 요구**에 불필요하게 끌려가지 않으며, **인터페이스 오염(interface pollution)** 을 방지한다.
- SRP와 밀접히 관련.

### 4.4. 예시(ATM UI)

- 입금/출금/이체를 모두 담은 **ATM UI 단일 인터페이스**는 오염 위험이 높음.
- 기능별로 `ATMWithdrawUI`, `ATMDepositUI`, `ATMTransferUI` **분리**가 바람직.

### 4.5. 결론

- **클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강요돼서는 안 된다.**
- **클라이언트가 다르면 인터페이스도 분리**하라.
- **~~Fat~~ 클래스/인터페이스**는 클라이언트들 사이에 **해로운 결합**을 만든다.

### 4.6. 체크리스트

-  인터페이스에 **클라이언트가 쓰지 않는 메서드**가 포함되어 있는가? → 분리.
-  **기능별로 응집된 인터페이스**인가, 아니면 **fat**한가? → 응집 높이고 분할.
-  변경이 특정 클라이언트에서만 발생해도 **다른 클라이언트가 영향**받는가? → 의존 축소.

## 5. 의존성 역전 원칙 (Dependency Inversion, DI)
### 5.1. 정의

- **정의**: “**상위 수준 정책 모듈**은 **하위 수준 세부 모듈**에 의존하지 말고, **명확한 인터페이스(추상)** 에 의존해야 한다.” 또한 “**추상은 세부에 의존하지 않고, 세부가 추상에 의존**해야 한다.”
- **요지**: “**구현이 아닌 인터페이스**에 맞춰 설계(Design to an interface)”—OCP를 실현하는 **메커니즘**.

### 5.2. 배경(Rationale)

- **추상(인터페이스/추상클래스)은 변동이 적고 확장·수정의 경첩 지점**이 된다 → 추상은 가능하면 수정하지 않게(OCP). 단, **변경 가능성이 매우 낮은 구체 타입(String 등)** 은 굳이 한 겹 더 감싸지 않아도 된다(예외).

### 5.3. 레이어링 가이드

- **추이적 의존(상위가 간접적으로 하위 유틸에 매달림) 회피** → 상·하위 레이어 사이에 **서비스 인터페이스(추상)** 를 세워 의존을 절단.

### 5.4. 대표 예시(Keyboard→Printer 복사)

- 절차적 설계: `Copy()`가 `ReadKeyboard()/WritePrinter()`에 직접 의존 → 출력 대상 추가 시 분기/수정 빈발.
- **DIP 적용**: `Reader/Writer` **인터페이스**에 의존하고 `Copy(Reader, Writer)`로 주입 → 키보드/프린터/디스크 등 **세부 구현 교체**가 수정 없이 가능.

### 5.5. OCP/LSP와의 관계

- **OCP(목표)** 를 달성하는 **수단이 DIP**, **LSP는 그 보험(대체 가능성 보증)**.

### 5.6. 휴리스틱

- **의심되면 간접화(Indirection)를 한 겹 추가**하되, 필요 이상 남발은 지양(추후 제거/우회는 쉬우나 사후 추가는 어려움).

### 5.7. 결론

- 절차적 구조는 **정책→세부** 의존이라 변경에 취약. OOP는 **정책·세부가 모두 추상**에 의존하도록 **의존을 뒤집는다**—**의존 역전이 되어 있으면 OO 설계, 아니면 절차적 설계**로 본다.

### 5.8. 체크리스트

-  상위 정책 코드가 **구체 클래스**가 아니라 **인터페이스/추상**에 의존하는가?
-  **추이적 의존**(상위→하위 유틸 체인)이 발생하지 않게 **서비스 인터페이스**로 절단했는가?
-  입출력/외부 자원 등은 `Copy(Reader, Writer)`처럼 **역전된 의존 + 주입** 패턴으로 설계했는가?