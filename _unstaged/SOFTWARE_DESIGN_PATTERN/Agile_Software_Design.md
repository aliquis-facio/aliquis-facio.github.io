# Agile Software

## Part 1. 애자일 개발
### Chapter 1. 애자일 실천방법

과거 소프트웨어 개발은 폭포수 모델 같은 선형적 접근을 주로 사용했음.
하지만 이는 변화하는 요구사항에 유연하게 대응하지 못하고, 프로젝트 후반부에 대규모 수정 비용을 초래함.

#### 애자일 연합

> 애자일 소프트웨어 개발 선언문
> * 프로세스와 툴보다 개인과 상호작용이 우선이다.
> * 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.
> * 계약 협상보다 고객 협력이 우선이다.
> * 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

##### 프로세스와 툴보다 개인과 상호작용이 우선이다.

뛰어난 팀원: 다른 동료와 함께 조화롭게 일할 수 있는 사람.
상호작용하는 능력은 다듬어지지 않은 프로그래밍 실력보다 더 중요하다.
알맞은 툴은 성공을 위해 매우 중요하지만 과유불급이다.
팀을 구성하는 일은 환경을 구축하는 일보다 더 중요하다.

##### 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.

팀은 설계 의사결정의 이유와 시스템을 설명하는 사람이 읽을 수 있는 형태로 된 문서를 만들어야 한다.
문서는 짧고 요약적이어야 한다. 최대 12 ~ 24p로 문서가 포괄적인 설계 원리와 가장 높은 시스템 단계의 구조에 대해서만 논해야 한다.
새로운 팀원과 친밀하게 일해야 한다.
**마틴의 문서화 제1법칙**: *그 필요가 급박하고 중요하지 않다면 아무 문서도 만들지 마라.*

##### 계약 협상보다 고객 협력이 우선이다.

성공적인 프로젝트를 위해서는 규칙적으로 자주 고객의 피드백을 받아야 한다.
최선의 계약서는 개발 팀과 고객이 함께 작업하면서 결정하는 것이다.

##### 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

계획을 세울 때는 그 계획이 탄력적이고 업무와 기술의 변화에 적응할 준비가 되어 있는지 확인해야 한다.
업무 환경은 변하기 쉽고, 그것은 고객의 요구사항을 변하게 만든다. 그리고 고객은 시스템이 일단 동작하기 시작하는 것을 보면 요구사항을 좀 더 높은 단계로 올리고 싶어 할 것이다. 마지막으로, 프로그래머는 요구사항을 알고 있고 이 요구사항이 변하지 않을 것이라고 확신할 수 있다 해도, 개발하는 데 얼마나 많은 시간이 걸릴지는 잘 예상하지 못한다.
계획은 그저 날짜뿐만이 아니라 모양 자체가 변경된다.
계획 전략은 다음 2주간의 세부적인 계획을 수립하고, 다음 3개월간의 계략적인 계획을, 그 이후로는 아주 대강의 계획을 세우는 것이다.
가까운 시일 내에 수행할 태스크에 대해서만 세부적인 계획을 짠다는 것을 의미한다.

#### 원칙

* 우리의 최고 가치는 유용한 소프트웨어의 빠르고 지속적인 공개를 통해 고객을 만족시키는 것이다.
	* 품질과 부분 구현 시스템의 빠른 공개 사이의 강한 관계
		* 첫 공개본에서 기능하는 부분이 적을수록 최종 공개본의 품질이 높아진다.
		* 자주 공개할수록, 최종 품질도 좋았다.
	* 애자일 실천방법은 빨리, 자주 공개하는 것이다. 가능하면 기본적인 시스템을 프로젝트 시작 후 처음 몇 주 안에 공개한다. 그리고 2주마다 기능성을 증가시킨 시스템을 계속 공개하려고 노력한다.
* 개발 후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 우위를 위해 변화를 이용한다.
	* 팀이 시장의 요구를 충족시키기 위해 무엇을 해야 하는 지 좀 더 배웠다 → 요구사항 변경은 긍정적이다.
	* 소프트웨어의 구조를 탄력적으로 유지하기 위해 노력하고, 따라서 요구사항이 변경됐을 때 시스템에 미치는 영향은 최소한의 것이 된다.
* 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라.
* 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다.
* 의욕적인 개인들을 중심으로 프로젝트를 구성해라. 환경과 필요로 하는 지원을 제공하고, 그들이 그 일을 해낼 것이라 믿고 맡겨둬라.
	* 사람이 성공의 가장 중요한 요소
* 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적이고 효과적인 방법은 직접 일대일로 **대화**하는 것이다.
* 개발 중인 소프트웨어가 진척 상황의 일차적 척도다.
	* 진척 상황을 현재 고객의 요구를 충족시키고 있는 소프트웨어의 비율로 측정한다.
* 애자일 프로세스는 **지속 가능한 개발**을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 속도를 유지할 수 있어야 한다.
* 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다.
* 단순성(아직 끝내지 않은 일의 양을 최대화하는 예술)은 필수적이다.
	* 가장 간단하고 가장 고품질의 작업을 오늘 행하고, 내일 문제가 생긴다면 그때 변경 작업을 하는 편이 쉬울 것이라고 확신한다.
* 최고의 아키텍쳐, 요구사항, 그리고 설계는 자기 조직적인 팀에서 나온다.
	* 책임감은 외부로부터 팀원 개개인에게 수여되는 것  X
* 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.

#### 효과

* 고객 만족도 향상: 요구사항 변경에 빠르게 대응 가능
* 코드 품질 향상: 지속적 테스트와 리팩토링을 통한 유지보수성 확보
* 팀 생산성 및 사기 향상: 자율성과 협업 강화

#### 결론

모든 소프트웨어 개발자와 모든 개발팀의 직업적 목표는 그들의 고용인과 고객에게 가능한 가장 높은 가치를 전달하는 것.
애자일 프로세스: 스크럼(SCRUM), 크리스털(Crystal), 기능 중심 개발(Feature Driven Development), 어댑티브 소프트웨어 개발(ADP: Adaptive Software Development), 익스트림 프로그래밍(XP: Extreme Programming) 등

---

### Chapter 2. 익스트림 프로그래밍 소개
#### 익스트림 프로그래밍 실천방법

익스트림 프로그래밍(XP: Extreme Programming): 애자일 방법 중 가장 유명, 단순하면서도 서로 의존적인 실천방법의 집합으로 구성됨.
목표: **품질, 적응성, 협업의 극대화**

#### 1. 고객 팀 구성원(고객과 협업)

고객: XP 팀의 고객은 기능 요소를 정의하고 우선순위를 매기는 개인 또는 그룹. XP 프로젝트에서는 고객이 누구든 간에 팀의 멤버이며, 팀에서 일할 수 있다.
고객에게 있어 최선의 상황은 개발자와 같은 공간에서 일하는 것이다. 차선은 고객이 개발자와 100피트 거리 내에서 일하는 것이다.

#### 2. 사용자 스토리

프로젝트 일정 계획을 세우기 위해서는 요구사항을 추정할 수 있을 만큼의 정보만 알면 된다.
요구사항의 구체적인 세부 내용은 시간이 지남에 따라 바뀌기 쉽다.
XP를 사용할 때 고객은 같이 합의해서 정한 색인 카드에 몇 개의 단어를 적어 그 대화 내용을 기억한다. 개발자는 고객이 색인 카드에 단어를 적을 때, 고객과의 대화를 바탕으로 추정한 내용을 카드에 기록한다.
사용자 스토리(user story)란 현재 진행 중인 요구사항에 관한 대화의 연상 기호다. 이것은 고객이 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획 툴이다.

#### 3. 짧은 반복

보통 **2주 단위** 반복 주기
매 반복(iteration)마다 동작하는 소프트웨어를 제공하고 고객의 피드백을 받음

##### 반복 계획

반복은 보통 2주 단위로 진행됨 → 마이너 공개(minor delivery)임을 뜻함.
반복 계획(iteraion plan)은 개발자가 세운 예산에 따라 고객이 선택한 사용자 스토리의 집합이다.
반복이 시작되면, 고객은 그 반복 동안에는 스토리 정의나 우선순위를 바꾸지 않는다고 동의함.
이 시기 동안, 개발자는 스토리를 자유롭게 태스크에 나눠 넣고 기술적, 업무적으로 가장 합리적인 순서로 그 태스크를 수행해나감.

##### 릴리즈 계획

다음 약 6번의 반복 일정을 정밀하게 표현하는 릴리즈 계획(release plan)을 만듦.
릴리즈: 대개 3개월 동안을 의미, 메이저 공개(major delivery)
릴리즈 계획은 개발자가 제시한 예산에 맞춰 고객이 선택한, 우선 순위가 정해진 ‘사용자 스토리’의 묶음으로 구성됨.

#### 4. 인수 테스트

사용자 스토리의 세부 사항은 고객이 명시한 인수 테스트(acceptance test)의 형태로 기록됨. 인수 테스트는 자동적으로, 또 반복적으로 실행될 수 있는 스크립트의 언어의 한 종류로 작성됨.
일단 시스템이 인수 테스트를 통과하면, 통과한 테스트의 본문에 추가되고 다시 실패하는 것이 허용되지 않음.

#### 5. 짝 프로그래밍

모든 운영 코드(production code)는 2명이 함께 작성
각 짝의 한 멤버는 코드를 짜고, 한 멤버는 에러와 개선점을 찾음.
짝은 적어도 하루에 한 번 바뀌어서 모든 프로그래머가 매일 서로 다른 두 짝으로서 일할 수 있게 해야 함.
협업 강화, 지식 공유, 결함 감소

#### 6. 테스트 주도 개발

모든 운영 코드는 실패하는 단위 테스트를 통과하기 위해 작성됨.
테스트 케이스(test case)와 코드를 작성하는 사이의 간격은 1분 정도로 매우 빠르다.
테스트 케이스의 완성된 본문은 코드와 함께 발전함. 이 테스트는 프로그래머로 하여금 프로그램이 잘 동작하는지 점검할 수 있게 해줌. 만약 어떤 짝이 프로그램을 조금 변경한다면, 바로 테스트해서 아무 문제가 없는지 확인할 수 있음. 이런 방식을 리팩토링(refactoring)을 굉장히 용이하게 함.
코드를 모듈별로 분리해 각각 독립적으로 테스트될 수 있게 해야 함. 이런 방식으로 작성되는 코드 구조는 상호 간섭이 아주 적은데, 객체 지향 설계 원칙은 이런 비간섭화를 구현하는 데 큰 역할을 한다.

#### 7. 공동 소유권

모든 팀원이 코드베이스의 어느 부분이든 개선 가능
지식 공유와 유연성 극대화

#### 8. 지속적인 통합

프로그래머는 자신의 코드를 체크인(check in)하고 하루에 몇 번씩 그것을 통합함.
규칙: 첫 번째로 체크인한 사람을 우선으로 해 나머지 사람의 코드를 병합함.
XP 팀은 비차단 소스 제어(nonblocking source control) 방식을 사용함. 이것은 다른 사람이 체크아웃(check out) 해간 것에 대한 고려 없이, 프로그래머들이 아무 때나 어떤 모듈이라도 체크아웃하도록 허용한다. 프로그래머가 모듈을 수정하고 난 뒤에 그것을 다시 체크인하려면, 먼저 그 모듈을 체크인한 다른 사람이 수정한 부분과 병합할 준비가 되어 있어야 할 것이다.
짝(pair)은 한두 시간 동안 한 태스크에 매달려 테스트 케이스와 운영 코드를 작성함. 그 후 테스트 진행하고 체크인 시도.

#### 9. 지속 가능한 속도

소프트웨어 프로젝트는 마라톤이다.
팀은 일정한 속도를 유지
XP 규칙은 팀이 초과 근무를 하지 않도록 해야 한다. 이 규칙의 유일한 예외는 릴리즈의 마지막 주다. 릴리즈라는 골에서 아주 가까운 거리에 있고 종점을 향해 전력 질주를 할 수 있다면, 초과 근무도 무방하다.

#### 10. 열린 작업 공간

팀은 열린 공간에서 함께 일한다. 2~4개의 워크스테이션이 설치된 테이블이 있고, 각 워크스테이션에는 짝이 나란히 앉을 수 있도록 2개의 의자가 있다. 벽에는 상황 차트, 태스크 명세(task breakdowns), UML 다이어그램 등이 펼쳐져 있다.

#### 11. 계획 세우기 게임

계획 세우기 게임의 정수는 업무와 개발의 책임 분리에 있다. 업무 관련 인력(고객)은 기능 요소가 얼마나 중요한지를 결정하고, 개발자는 그 기능 요소를 구현하는 데 얼마나 비용이 들 것인지를 결정한다.
각 릴리즈와 반복을 시작할 때, 개발자는 가장 최근의 반복이나 릴리즈에서 완성할 수 있었던 양을 기준으로 예산을 세워 고객에게 제출한다. 고객은 총비용의 합이 예산을 넘지 않는 정도로 스토리를 선택함.

#### 12. 단순한 설계

XP 팀은 그들의 설계를 가능한 한 단순하고 표현적으로 만든다. 현재 반복에서 작업하기로 계획했던 스토리에만 초점을 맞추어 공략한다. 한 반복에서 다음 반복으로 넘어갈 때 시스템의 설계를 마이그레이션해서, 시스템이 현재 구현하고 있는 스토리에 가장 적합한 설계가 되도록 한다.
XP 팀이 기반구조(infrastructure)을 이용해 시작하지 않을 것임을 의미함. 팀의 첫 번째 행동은 가능한 한 가장 단순한 방식으로 동작하는 스토리의 첫 묶음을 얻어내는 것이 될 것이다.

세 가지 XP 지침
##### 어떻게든 동작하는 가장 단순한 것을 생각한다.

XP 팀은 항상 현재의 스토리 묶음에 적용할 수 있는 가장 간단한 설계 옵션을 찾으려고 함.

##### 필요하지 않을 것이라는 가정에서 시작한다.

XP 팀은 확실히 필요해지기 전에 기반구조를 추가하고 싶은 유혹에 저항하지 않을 때 무슨 일이 일어날 것인지 심각하게 고려함. 즉, 기반구조가 필요하지 않을 것이라는 가정하에 프로젝트를 시작함. 비용 적인 효과가 발생한다는 근거가 있을 때 기반구조를 추가함.

##### 코드를 중복해서 쓰지 않는다.

XP를 수행하는 사람은 코드 중복을 허용하지 않으며, 중복 코드가 발견될 때마다 이를 제거함.
함수로 바꾸거나 템플릿 메소드(template method) 패턴을 상용함.
중복성(redundancy)을 제거하는 최선의 방법은 추상화(abstraction)다.
중복성을 제거하기 위해 팀은 많은 추상형을 만들고 그 결과 결합도(coupling)가 낮아짐.

#### 13. 리팩토링

리팩토링은 행위에 영향을 주지 않고 시스템의 구조를 개선하는 일련의 작은 변환을 만드는 방식이다. → 가독성과 유지보수성 확보
각각의 작은 변환이 끝나고 나면, 아무 문제도 없음을 확인하기 위해 단위 테스트를 실시함. 그리고 각 변환 끝에 테스트를 실시하면서 다음 변환을 계속 수행함.
리팩토링은 프로젝트나 릴리즈, 반복, 심지어 일과가 끝날 때도 계속 수행됨. 프로그래머는 1시간 혹은 30분마다 리팩토링을 함.

#### 14. 메타포

메타포(metaphor)는 전체 시스템을 하나로 묶는 큰 그림이다. 이것은 모든 개별적인 모듈의 위치와 형태를 명백하게 만드는 시스템의 비전(vision)이다. 모듈의 형태가 메타포와 일치하지 않는다면 그 모듈이 잘못되었음을 알 수 있다.
메타포는 시스템을 이름으로 요약하는데, 이 이름은 시스템의 요소에 기호를 부여하고 그 관계를 정의하는 것을 도와줌.
시스템 구조와 모듈 관계를 이해시키는 공통 비유(메타포)를 사용

#### 결론

익스트림 프로그래밍은 애자일 개발 프로세스를 구성하는 단순하고 구체적인 방식의 집합이다.
XP는 소프트웨어 개발을 위한 범용 방식이다.

---

### Chapter 3. 계획 세우기

XP에서의 계획은 고객과 개발자가 함께 사용자 스토리를 정의하고, 이를 반복적으로 세분화/우선순위화하면서 프로젝트를 이끌어가는 과정이다.
중요한 점은 계획은 한 번 정하고 끝나는 것이 아니라, 프로젝트 전반에서 지속적으로 보완되는 활동이라는 것이다.

#### (1) 초기 탐색 (Initial Exploration)

- 프로젝트 시작 시 고객과 개발자가 주요 **사용자 스토리(user stories)** 를 도출한다.
- 새로운 스토리는 프로젝트 도중에도 계속 추가될 수 있다.
- 개발자는 각 스토리에 대해 상대적 **비용(점수) 추정**을 제공한다.

#### (2) 스파이킹, 분할, 속도 (Spiking, Splitting, Velocity)

- 스토리가 너무 크면 쪼개고(split), 너무 작으면 합쳐서 관리한다.
	- 스토리가 분할되거나 합쳐지면, 다시 추정해야 한다.
	- 스토리를 분할하거나 합치는 주된 이유는 정확한 추정을 할 수 있을 정도의 크기로 만들기 위해서다.
	- 스토리의 정확한 크기를 알기 위해서는 속도라는 요소가 필요하다.
- 초기 **프로토타입(spike solution)** 을 통해 대략적인 속도(velocity: 단위 기간에 처리 가능한 스토리 포인트 양)를 측정할 수 있다.
- 이런 프로토타입 단계를 **스파이크(spike)** 라고 한다.

#### (3) 릴리즈 계획 (Release Planning)

- 고객은 주어진 속도를 기준으로 스토리의 **비즈니스 가치와 비용**을 평가하여 우선순위를 정한다.
	- 중요하지만 비용이 비싼 것은, 덜 중요하지만 비용이 훨씬 싼 것을 위해 처리를 미뤄야 한다. 이런 선택이 업무 의사결정이다.
	- 비용 대비 효과가 가장 큰 스토리를 선택한다.
- 릴리즈 시점은 보통 **2~4개월 후**를 기준으로 설정한다.
	- 고객은 그 릴리즈에 구현되었으면 하는 스토리와 대략적인 구현 순서를 선택한다.

#### (4) 반복 계획 세우기 (Iteration Planning)

- 한 이터레이션(2주 내외)마다 고객과 개발자가 현재 속도에 맞추어 구현할 스토리를 선택한다.
- 개발자는 구현 순서를 정하고, **반복이 시작되면 스토리에 변경을 허용하지 않는다**.
	- 개발자는 기술적으로 가장 합리적인 순서에 따라 스토리를 구현한다.
	- 모든 스토리 구현이 완료되지 않은 경우에도 반복은 정해진 날짜에 끝난다.
	- 완료한 스토리의 추정 소요 시간을 모두 더하여, 반복의 속도를 계산한다.

#### (5) 태스크 계획 (Task Planning)

* 태스크는 한 개발자가 4~16시간 동안 구현할 수 있는 것이다.
- 선택된 스토리를 더 작은 **태스크 단위**로 분해한다.
- 각 태스크는 점수화되며, 개발자들이 협업하여 유연하게 분담한다.
	- 개발자가 전체 프로젝트에 대해 더 알게 될수록, 프로젝트 팀은 더욱 탄탄해지고 더 많은 정보를 알게 된다.
	- 각 개발자는 가장 최근의 반복에서 자신이 어떻게든 구현했던 태스크 포인트가 몇 개인지 알고 있다. 이 숫자는 그들의 개인적인 예산이며, 어떤 팀원도 자신의 예산보다 더 많은 포인트에 참여하지 않는다.
	- 태스크 선택 과정은 모든 태스크가 할당되거나 모든 개발자가 그들의 예산을 다 사용할 때까지 계속된다.
- 만약 태스크가 수행 불가하면 고객에게 다시 우선순위 조정이나 제거를 요청한다

#### 반환점

* 반복이 반쯤 진행됐을 때, 팀은 미팅을 갖는다.
	* 계획한 스토리의 반 정도가 완료되어야 한다.
* 반복이 끝날 때 모든 스토리가 완료되도록 재분배 방법을 찾고, 못 찾을 경우 고객에게 보고한다.
* 고객은 반복에서 어떤 태스크나 스토리를 제외할 것인지를 결정할 수 있다.

#### 반복

* 각 반복(2주)의 마지막에는 현재 동작하는 실행 가능한 부분을 고객 앞에서 시연한다.
* 고객은 시연된 프로젝트를 통해 외관, 느낌, 성능을 평가해야 하고, 새로운 사용자 스토리를 통해 피드백을 제공한다.
* 고객은 진행 상황을 수시로 알 수 있으며, 속도도 측정할 수 있다.

#### 3. 의미와 특징

- **계획의 목적**은 예측이 아니라 **협업과 적응**이다.
- 전통적 계획(상세 일정·문서화 중심)과 달리, XP의 계획은 **고객과 개발자가 함께 의사결정을 내리는 참여형 활동**이다.
- **속도(velocity)** 개념이 있어, 추정과 실제 진행 상황 간의 차이를 줄여 나가며 점점 더 정확해진다.
- 최소의 비용으로 최대의 사업상 가치를 얻을 수 있도록 팀을 제어할 수 있다.

---

### Chapter 4. 테스트 주도 개발
#### 1. 테스트의 목적

- 테스트는 단순히 **버그 검출**이나 **검증(verification)** 에만 그치지 않는다.
- XP(익스트림 프로그래밍)에서는 테스트가 **설계와 개발 과정의 중심**에 놓인다.
- 테스트를 통해 코드가 올바르게 동작함을 확인할 뿐 아니라, **설계 결정을 검증하고 코드 개선(리팩토링)을 안전하게 뒷받침**한다 .

#### 2. 테스트 주도 개발 (TDD: Test-Driven Development)

* 포괄적인 테스트 집합의 존재에서 이끌어낼 수 있는 이점
	* 프로그램의 모든 단일 함수가 그 동작을 검증하는 테스트를 갖게 된다.
	* 테스트를 먼저 작성할 경우, 프로그래머가 다른 관점에서 문제를 해결할 수 있다.
		* 프로그래머는 작성할 프로그램을 그 프로그램의 호출자 관점에서 봐야 한다.
	* 프로그래머는 자신이 반드시 테스트 가능한 프로그램을 설계하도록 강제할 수 있다.
		* 테스트를 먼저 작성한다는 건 프로그래머가 소프트웨어를 다른 환경과 분리하도록 강제하는 것이다.
	* 테스트가 문서화의 귀중한 한 형태로 기능할 수 있다.
- **실패하는 테스트를 먼저 작성**한 후, 이 테스트를 통과하는 최소한의 코드를 작성한다.
- 그 다음 **리팩토링**으로 코드를 정리하고 개선한다.
- 이 과정을 반복함으로써 코드는 점차 **견고하고 깔끔한 구조**를 갖게 된다.

#### 테스트 우선 방식 설계의 예

* 계획된 프로그래밍(intentional programming): 프로그래머는 자신의 의도를 구현하기 전에, 먼저 그 의도를 가능한 한 단순하고 읽기 편하게 만들어 테스트로 제시한다.
* 테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.
* 테스트는 프로그램이 동작하는 방식을 말해준다.
* 테스트는 프로그램을 설명하는 컴파일 가능하고 실행 가능한 문서가 된다.

#### 테스트 분리

* 운영 코드를 만들기 전에 테스트를 먼저 작성할 경우, 소프트웨어에서 분리해야 할 부분이 드러나곤 한다.
* 의사 객체(MOCK OBJECT) 패턴을 이용하는 것이다.

#### 운 좋게 얻은 분리

* 코드보다 테스트를 먼저 작성하면 설계가 개선된다.
	* 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.

#### 3. 인수 테스트 (Acceptance Tests)

* 단위 테스트는 시스템의 작은 구성 요소가 기대한 대로 동작하는지 여부는 검증하지만, 시스템이 전체로서 제대로 작동하는지는 검증하지는 않음. → 필수적 but, 검증툴로서는 불충분
* 단위 테스트는 시스템의 개별적인 메커니즘을 검증하는 화이트박스 테스트
* 인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 블랙박스 테스트
	* 특별한 스크립트 언어로 작성됨
	* 기능 요소의 궁극적인 문서화 형태임
	* 시스템의 기능 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행함.
- 각 사용자 스토리는 반드시 **인수 테스트**로 표현된다.
- 인수 테스트는 **고객 요구사항 충족 여부**를 자동으로 검증하는 역할을 한다.
- 즉, 단위 테스트는 개발자가 코드를 위한 것이고, 인수 테스트는 고객이 기능을 확인하는 기준이다.

#### 4. 테스트의 가치

* 테스트 실행이 간단함 → 테스트를 좀 더 자주 실행함 → 테스트에 어긋나는 것들을 좀 더 빨리 찾게 됨
- **설계 가이드**: 테스트는 개발자가 코드의 사용법을 먼저 생각하도록 하여, 더 나은 설계를 유도한다.
- **문서화**: 테스트 코드는 살아 있는 문서로 기능을 설명한다.
	- 단위 테스트와 인수 테스트 모두 컴파일 및 실행 가능한 문서화의 한 형태 → 정확하고 신뢰성이 있다
	- 모호하지 않은 언어로 작성됨
- **회귀 방지**: 기존 기능이 깨지지 않음을 자동으로 확인해준다.
- **변화 수용**: 새로운 요구사항을 추가할 때도, 기존 테스트가 안전망 역할을 한다.

#### 5. 애자일과 테스트

- 애자일 개발에서 테스트는 단순히 품질 보증(QA)이 아니라, **개발 프로세스의 핵심 활동**이다.
- “테스트를 작성하지 않으면, 기능을 완전히 구현했다고 말할 수 없다”는 철학을 따른다.

---

### Chapter 5. 리팩토링
#### 1. 리팩토링의 정의와 필요성

- **정의:** 마틴 파울러(Martin Fowler)의 정의에 따르면, 리팩토링은 **외부 동작(기능)을 바꾸지 않고 코드의 내부 구조를 개선하는 것**이다. **소프트웨어 시스템을 변경하는 프로세스**
- 단순히 “코드가 잘 돌아가니 됐다”라는 사고방식이 아니라, 코드가 **읽기 쉽고 변경하기 쉬워야 한다**는 점을 강조한다.
- 소프트웨어 모듈의 3대 기능:
    1. **동작**: 작업을 실행한다.
    2. **변경**: 변경을 수용할 수 있다.
    3. **의사소통**: 개발자와 의사소통한다.
- 모듈이 변경이나 의사소통에 실패한다면 리팩토링이 필요하다.
* IntelliJ IDEA 리팩토링 브라우저

```java
private static int calcMaxPrimeFactor() {
	// p가 소수일 때, p의 모든 배수를 지운다
	// 따라서 지워지는 모든 배수는 인수로 p와 q를 갖는다.
	// 'p > 배열 크기의 aqrt(제곱근)'일 경우, q는 1보다 클 수 없다.
	// 따라서 p는 이 배열의 가장 큰 소인수이고,
	// 루프 횟수의 한계 값이기도 하다.
	double maxPrimeFactor = Math.sqrt(isCrossed.length) + 1;
	return (int) maxPrimeFactor;
}
```

#### 2. 리팩토링의 목적

- **코드 가독성 향상**: 명확한 변수명, 단순화된 구조.
- **변경 용이성 확보**: 새로운 요구사항을 쉽게 반영할 수 있도록 코드 유연성을 높임.
- **중복 제거와 일관성 유지**: 같은 로직을 하나의 모듈로 통합.
- **지속 가능한 개발**: 기술 부채를 줄이고, 장기 유지보수성을 확보.

#### 3. 리팩토링 과정

- **TDD와 결합**: 테스트가 안전망 역할을 하므로 안심하고 구조를 바꿀 수 있음.
- **단계적 개선**: 한 번에 큰 변화를 주는 것이 아니라, 작은 단계를 거쳐 코드 품질을 점진적으로 향상시킴.
- **예제**: 소수 판별 알고리즘을 점진적으로 개선하며 성능과 가독성을 동시에 확보하는 과정을 설명.

#### 4. 리팩토링의 효과

- 코드는 더 간결해지고, 읽기 쉬워짐.
- 유지보수 시 버그 발생 가능성을 줄임.
- **비유:** 리팩토링은 주방 청소와 같다. 한 번 해치우는 게 아니라, 지속적으로 관리해야 쾌적하고 효율적으로 유지된다.

##### 5. 핵심 교훈

- 리팩토링은 선택 사항이 아니라 **지속 가능한 소프트웨어 개발의 필수 요소**다.
- 코드를 단순히 “돌아가게 만드는 것”에서 끝내지 말고, **사람이 읽고 바꿀 수 있는 코드**로 만들어야 한다.
- 원칙·패턴만으로는 부족하고, 개발자의 **훈련·규율·코드 미학에 대한 감각**이 필요하다.

---

### Chapter 6. 프로그래밍 에피소드
#### 1. 목적

- 앞서 다룬 애자일 핵심 기법들(테스트, 리팩토링, 계획)을 실제 코딩 과정에서 **어떻게 적용하는지** 보여주기 위해 **실제 프로그래밍 사례**를 다룸.
- 주제: **볼링 점수 계산 프로그램** 개발.

#### 2. 개발 시나리오

- 두 명의 프로그래머(저자 Bob Martin과 Bob Koss)가 **페어 프로그래밍**을 통해 문제를 해결.
- 요구사항:
    - 각 투구(throw)에서 쓰러뜨린 핀 수를 기록.
    - 스트라이크, 스페어, 일반 점수 규칙을 적용해 최종 점수를 계산.
    - 게임 단위로 점수를 집계.

#### 3. 개발 과정
##### (1) 사용자 스토리 정의

- **사용자 스토리**: “볼링 게임의 점수를 계산할 수 있어야 한다.”
- 이를 더 세분화: 한 게임, 여러 프레임, 스트라이크/스페어 처리 등.

##### (2) 테스트 주도 개발 (TDD)

- 항상 **실패하는 테스트를 먼저 작성** → 해당 기능을 구현 → **테스트 통과 후 리팩토링**.
- 예시 흐름:
    1. `Game` 클래스에 `roll()` 메서드(투구 기록)와 `score()` 메서드(총점 계산)를 정의.
    2. 단순한 케이스(예: 모두 0점)부터 테스트 작성.
    3. 점차 스트라이크, 스페어와 같은 복잡한 규칙으로 확장.

##### (3) 리팩토링

- 구현이 복잡해질 때마다 **메서드 추출**, **변수 이름 개선**, **중복 제거**를 통해 구조 개선.
- 점수 계산 로직을 `Scorer` 클래스로 분리하여 **단일 책임 원칙(SRP)**을 적용.

##### (4) 페어 프로그래밍 협업

- 한 명은 **드라이버(driver)**로 실제 코드를 작성, 다른 한 명은 **내비게이터(navigator)**로 설계와 개선 방향을 제안.
- 이 과정에서 계속 토론하며 코드 품질을 높임.

#### 4. 결과

- 완성된 프로그램은 **모든 점수 규칙을 처리**하면서도,
    - 테스트가 전체 기능을 보장하는 안전망 역할.
    - 리팩토링을 통해 코드가 간결하고 유지보수하기 쉬움.
- **애자일 개발 실천법(XP 기법)**이 실제로 어떻게 작동하는지 보여주는 대표 사례.

#### 5. 요약

- **테스트 주도 개발(TDD)**: 기능 개발 전에 테스트를 작성하면 설계가 단순해지고 안정성이 확보된다.
- **리팩토링**: 깨끗한 코드 유지를 위해 필수적이다.
- **페어 프로그래밍**: 두 명이 협력함으로써 코드 품질과 지식 공유가 강화된다.
- **애자일 실천법의 통합 효과**: 계획, 테스트, 리팩토링, 협업이 유기적으로 작동하여 안정적이고 유연한 개발 가능.

---


## Part 2. 애자일 설계

**기민성(agility)**: 아주 조금씩 소프트웨어를 만들어나가는 것

**객체 지향 설계 원칙**
* SRP(Single Responsibility Principle): 단일 책임 원칙
* OCP(Open-Closed Principle): 개방 폐쇄 원칙
* LSP(Liskov Substitution Principle): 리스코프 치환 원칙
* DIP(Dependency Inversion Principle): 의존 관계 역전 원칙
* ISP(Interface Segregation Principle): 인터페이스 분리 원칙

설계의 악취는 대개 하나 이상의 원칙을 위반했을 때 발생.
아무 악취도 나지 않을 때는 원칙을 적용하지 않음. 그저 원칙이라는 이유만으로 무조건 따르는 것은 좋지 않음.

### Chapter 7. 애자일 설계란 무엇인가?

UML 다이어그램 ⊂ 설계
소프트웨어 프로젝트의 설계는 추상적인 개념 → 구체적인 각 모듈, 클래스, 메소드의 형태와 구조뿐만 아니라 프로그램의 전체 형태와 구조와도 관련됨. 최종 구현은 소스 코드.

#### 1. 애자일 설계의 의미

- 소프트웨어 설계는 처음부터 완벽하게 하는 것이 아니라 **작은 단위의 반복적인 개발** 속에서 **점진적으로 진화**하는 것.
- 설계의 목표는 **유연성, 유지보수성, 재사용성**을 확보하는 것.
- 미래의 요구를 과도하게 예측하는 대신, **현재의 필요에 집중**하여 설계를 단순화하고 필요할 때 개선(refine)한다.

#### 2. 나쁜 설계의 징후 (Symptoms of Poor Design)

애자일 설계가 강조되는 이유는, 잘못된 설계가 아래와 같은 문제를 일으키기 때문이다:
1. **경직성(Rigidity)** – 작은 변화에도 전체 시스템을 크게 수정해야 함.
	- 의존적인 모듈에서 단계적으로 계속 변경을 일으킴
2. **취약성(Fragility)** – 한 부분을 수정하면 다른 부분이 쉽게 깨짐.
	- 변경한 영역과 아무런 관계가 없는 영역에서 문제가 발생함
3. **비재사용성(Immobility)** – 다른 프로젝트나 맥락에서 재사용하기 어려움.
	1. 부동성: 다른 시스템에서 유용하게 쓸 수 있는 부분을 포함하고 있지만, 그런 부분을 원래 시스템에서 분리하는 수고와 위험성이 지나치게 클 때 설계는 움직이게 할 수 없다.
4. **점착성(Viscosity)** – 좋은 방법보다 잘못된 방법을 쓰는 것이 더 쉬운 상황.
	- 소프트웨어의 점착성: 변경사항을 마주했을 때, 개발자는 보통 그 변경을 수행하는 한 가지 이상의 방법을 찾는다. 그중 일부는 설계를 유지하는 방법이고, 나머지는 그렇지 않다. 설계 유지 방법이 엉터리 방법보다 사용하기 어렵다면, 설계의 점착성을 높아진다. 이 경우 잘못된 동작을 하기는 쉽지만, 옳은 동작을 하기는 어렵다. 프로그래머는 설계를 유지할 수 있도록 변경이 쉬운 소프트웨어를 설계하고 싶어 한다.
	- 환경의 점착성: 개발 환경이 느리고 비효율적일 때 발생
5. **불필요한 복잡성(Needless Complexity)** – 실제 필요 없는 구조나 기능을 미리 설계해 과도하게 복잡해짐.
6. **불필요한 반복(Needless Repetition)** – 코드 중복.
7. **불투명성(Opacity)** – 코드가 복잡하고 읽기 어려워 의도를 이해하기 힘듦.

#### 무엇이 소프트웨어의 부패를 촉진하는가?

애자일이 아닌 환경에서는, 초기 설계에서 예상하지 않았던 요구사항 변경 때문에 설계가 퇴화하게 된다. 대개 이런 변경은 빠르게 이루어져야 하고, 이 일은 원래의 설계 철학에 익숙하지 않은 개발자들이 맡게 된다.
하지만 설계 퇴화 문제에 있어 요구사항의 표류를 탓할 수는 없다.

#### ‘Copy’ 프로그램

대부분의 소프트웨어 프로젝트에서 가장 변덕스러운 요소는 바로 요구사항이다.
우리는 변하는 요구사항의 세계에 살고 있고, 우리가 만든 소프트웨어가 이런 변화 속에서 살아남을 수 있게 만드는 것이 바로 우리가 해야 하는 일이다.

STRATEGY 패턴

#### 애자일 개발자는 해야 할 일을 어떻게 알았는가?

의존성의 방향, 직접 의존 → 하위 수준의 세부 사항이 바뀔 때, 상위 수준의 정책이 영향을 받게 됨.
1. 그들은 애자일 실천 방법을 다라 하며 문제를 찾아냈다.
2. 그들은 설계 원칙을 적용해 문제를 진단했다.
3. 그리고 적절한 디자인 패턴을 적용해 문제를 해결했다.

#### 가능한 한 좋은 상태로 설계 유지하기

설계를 가능한 한 적절하고 명료한 상태로 유지하기 위해 애쓴다
애자일 개발자는 매일, 매시간, 심지어 분마다 소프트웨어를 가능한 한 명료하고, 간단하고, 표현적인 상태로 유지한다.
설계는 명료한 상태로 유지되어야 한다. 그리고 설계의 가장 중요한 표현인 소스 코드 역시 명료한 상태로 유지되어야 한다.

#### 3. 객체지향 설계의 핵심 원칙 (Preview)

애자일 설계는 이러한 문제를 해결하기 위해 **객체지향 설계 원칙**(SOLID 등)을 적용한다.
- SRP (단일 책임 원칙)
- OCP (개방-폐쇄 원칙)
- LSP (리스코프 치환 원칙)
- DIP (의존 역전 원칙)
- ISP (인터페이스 분리 원칙)
이 원칙들은 “설계의 냄새(smell)”를 줄이고, 소프트웨어의 구조를 단순하고 명확하게 유지하는 데 도움을 준다.

#### 4. 요약

- **설계는 정적 산물이 아니라 동적인 과정**이다.
	- 애자일 설계는 과정이지, 결과가 아니다. 이것은 원칙, 패턴, 그리고 소프트웨어의 구조와 가독성을 향상하기 위한 방식의 연속적인 적용이다. 모든 시점에서 시스템의 설계를 가능한 한 간단하고, 명료하고, 표현적으로 유지하려는 노력이다.
	- 원칙과 패턴은 매 주기를 거치면서 코드 및 코드가 포함하는 설계를 명료하게 유지하려는 시도의 일환으로 적용된다.
- **좋은 설계란 미래를 완벽히 예측하는 것이 아니라, 변화에 쉽게 적응할 수 있도록 단순하고 유연하게 유지하는 것**이다.
- 따라서 애자일 설계는 “필요할 때, 필요에 맞게, 지속적으로 개선하는 설계”이다.

---

### Chapter 8. 단일 책임 원칙

**응집도(cohesion)**: 모듈 요소 간의 기능적인 연관
→ 모듈이나 클래스의 변경을 야기하는 응집력

#### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

- **정의:**  한 클래스는 **오직 하나의 변경 이유(reason to change)**만 가져야 한다.
- 즉, 클래스는 단 하나의 책임(Responsibility)만 가져야 하며, 그 책임을 수행하는 데 집중해야 한다.

## 2. 왜 중요한가?

- 여러 책임을 가진 클래스는 **변경에 취약**하다.
    - 각 책임이 변경의 축임 → 요구사항이 변경될 때, 이 변경은 클래스 안에서의 책임 변경을 통해 명백해짐.
    - 한 기능을 수정했을 때, 관련 없는 기능까지 영향을 받을 수 있음.
    - 이로 인해 코드 유지보수가 어려워지고, 의도치 않은 버그가 발생.
- **응집도(cohesion)** 가 높은 클래스는 설계가 단순하고, 변경 범위가 명확하다.

## 3. 예시

- **잘못된 사례:**  `Rectangle` 클래스가 **기하학적 계산**(넓이, 둘레 등)과 **화면 출력**(그리기)을 동시에 책임진다면, 출력 로직이 바뀔 때 기하학적 코드까지 수정해야 한다.
	- ![](20250924165209.png)
- **개선된 설계:**  `Rectangle`은 기하학적 계산만 담당하고, 출력은 `RectanglePrinter` 같은 별도 클래스가 담당해야 한다.
	- ![](20250924165403.png)

#### 책임이란 무엇인가?

책임(responsibility): SRP의 맥락에서, 변경을 위한 이유로 정의됨
→ 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것임.

애플리케이션이 어떻게 바뀌느냐에 따라 책임을 분리하느냐 마냐가 달려있음.
→ 애플리케이션이 서로 다른 시간에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면, 분리할 필요가 없음. 오히려 분리할 경우, 불필요한 복잡성이 발생함.
변경의 축은 변경이 실제로 일어날 때만 변경의 축임.

#### 결합된 책임 분리하기

바람직한 일은 아니지만 모든 의존성은 필요악일 수 있다. 하드웨어나 OS의 세부적인 사항과 관련된 이유로 인해, 오히려 책임이 결합되도록 만드는 경우가 종종 있다. 하지만 인터페이스는 분리하여 애플리케이션의 나머지 부분에 한해 개념을 분리했다.

#### 4. SRP 위반의 결과

- **변경 비용 증가:** 작은 변경이 여러 부분의 코드를 수정하게 만듦.
- **재사용성 저하:** 클래스가 불필요하게 많은 책임을 가지면 재사용하기 어려워짐.
- **이해도 하락:** 클래스가 커지고 복잡해져 의도를 파악하기 어려워짐.

#### 5. SRP 준수의 효과

- **변경 용이성 증가:** 책임이 분리되므로 특정 기능 변경 시 해당 클래스만 수정하면 됨.
- **재사용성 향상:** 잘 정의된 책임을 가진 클래스는 다른 맥락에서도 활용하기 쉬움.
- **코드 가독성 향상:** 클래스의 역할이 명확해져 코드 이해가 쉬워짐.

#### 6. 핵심 교훈

- 클래스 설계 시, **“이 클래스가 변경될 이유가 몇 개인가?”** 를 스스로 물어봐야 한다.
- 두 개 이상의 변경 이유가 있다면 SRP 위반 가능성이 높으므로 책임을 분리해야 한다.

---

### Chapter 9. 개방 폐쇄 원칙

> 모든 시스템은 생명주기 동안에 변화한다. 이것은 개발 중인 시스템이 첫 번째 버전보다 오래 남길 원한다면 반드시 염두에 두어야 할 사실이다.
> *Ivar Jacobson*

#### 1. 개방-폐쇄 원칙 (OCP, Open–Closed Principle)

- **정의:**  소프트웨어 엔티티(클래스, 모듈, 함수 등)는 **확장에는 열려(Open for extension)** 있으면서, **수정에는 닫혀(Closed for modification)** 있어야 한다.
- 즉, 새로운 기능을 추가할 때 기존 코드를 수정X, 새로운 코드 추가를 통해 확장할 수 있어야 한다.

#### 상세 설명

두 가지 주요 속성
1. 확장에 대해 열려 있다: 모듈의 행위가 확장될 수 있다. 애플리케이션의 요구사항이 변경될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
2. 수정에 대해 닫혀 있다: 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

#### 2. 왜 중요한가?

- 변화는 불가피하다. → 요구사항이 바뀔 때마다 기존 코드를 고친다면 시스템은 **취약하고 불안정**해짐.
- OCP를 따르면 기존 코드를 건드리지 않고 새로운 기능을 추가하므로 **안정성과 재사용성**이 높아진다.

## 3. OCP 달성 방법

추상화는 추상 기반 클래스이자, 모든 가능한 파생 클래스를 대표하는 가능한 행위의 제한되지 않은 묶음이다.

모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다. 그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

추상 클래스는 자신을 구현하는 클래스보다도 클라이언트에 더 밀접하게 관련되어 있다.

- **추상화(Abstraction)와 다형성(Polymorphism) 활용**
    - 공통 인터페이스(또는 추상 클래스)를 정의하고,
    - 새로운 기능은 인터페이스를 구현한 새로운 클래스 추가로 해결.
- **예시:**
    - 도형(Shape) 클래스 계층:
        - 추상 클래스 `Shape` → `draw()` 메서드 정의.
        - 새로운 도형(예: Circle, Square, Triangle)은 `Shape`를 상속받아 `draw()` 구현.
        - 이렇게 하면 새로운 도형 추가 시 기존 코드를 수정할 필요 없음.
![](20250924171853.png)
![](20250924171914.png)

## 4. OCP 위반 사례

- 새로운 기능을 추가할 때마다 `if-else`나 `switch-case`문을 수정해야 하는 경우.
- 예: `drawShape(Shape s)` 함수 안에서 Circle, Square를 `if`로 구분해 처리. → 새로운 도형을 추가하면 함수를 매번 수정해야 함.

#### 예상과 ‘자연스러운’ 구조

일반적으로, 모듈이 얼마다 ‘닫혀’ 있든지 간에, 닫혀 있지 않은 것에 대한 변경은 항상 존재한다. 모든 상황에서 자연스러운 모델은 없다.
폐쇄는 완벽할 수 없기 때문에, 전략적이어야 한다. 즉, 설계자는 자신의 설계에서 닫혀 있는 변경의 종류를 선택해야 한다.
어떤 변경이 있을 법한지 어떻게 알 수 있을까? 적절한 연구를 하고, 적절한 질문을 던지고, 경험과 상식을 이용해야 한다. 그리고 그 모든 것을 한 후에, 변경이 일어날 때까지 기다린다.

#### ‘올가미’ 놓기

지나치고 불필요한 추상화로 설계에 부하를 주지 않으려면, 추상화가 필요할 때까지 기다렸다가 올가미를 놓는 편이 차라리 낫다.

처음에는 코드가 변경되지 않을 것이라 생각하고 작성한다.
첫 번째 총알은 그냥 맞고, 그 총에서 쏘는 다른 총알에 대해서는 확실히 보호한다.

##### 변경 촉진하기

* 테스트를 먼저 작성한다. 테스트를 먼저 작성함으로써, 시스템을 테스트 가능한 것으로 만들 수 있다.
* 아주 짧은 주기로(주보다는 일 단위로) 개발한다.
* 기반구조보다 기능 요소를 먼저 개발하고, 자주 이 기능 요소를 이해당사자에게 보여준다.
* 가장 중요한 기능 요소를 먼저 개발한다.
* 소프트웨어를 빨리, 그리고 자주 릴리즈한다.

#### 명시적인 폐쇄를 위해 추상화 사용하기

폐쇄는 추상화에 기반을 둔다
순서에 대해 닫으려면, 순서 추상화를 만들어라

## 5. 한계

- 모든 변경을 100% 막을 수는 없다.
- 예를 들어, 시스템의 **기본 아키텍처 자체가 바뀌는 경우**는 기존 코드를 수정할 수밖에 없다.
- 따라서 OCP는 절대적인 규칙이 아니라 **변화가 예상되는 지점에 적용하는 설계 지침**이다.

## 6. 효과

- 변경 요구가 생겨도 기존 코드는 안정적으로 유지됨.
- 새로운 기능 추가가 용이 → 확장성 증가.
- 기존 코드와 신규 기능의 결합도가 낮아져 **유지보수성** 향상.