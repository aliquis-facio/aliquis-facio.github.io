# Insecure Design
## 1. 배경 (Background)

- **순위 변화**
    - 2021에서 **#4**였던 Insecure Design이 2025 RC1에서는 **#6**으로 두 단계 하락.
    - 그 사이에 **A02: Security Misconfiguration**와 **A03: Software Supply Chain Failures**가 치고 올라오면서 밀려난 형태. 
- **카테고리 성격*
    - 2021년에 처음 도입된 비교적 새로운 항목으로, 그 이후로
        - **위협 모델링(threat modeling)**
        - **보안 설계(secure design)**  
            쪽에 업계 전반의 관심과 개선이 눈에 띄게 늘어났다고 평가. 
    - 핵심은 “**설계 및 아키텍처 수준의 결함**”에 초점을 맞추는 것.
        - 안전한 설계 패턴과 레퍼런스 아키텍처 활용을 강조.
        - 비즈니스 로직 상의 설계 실수(예: “원하지 않는 상태 변화”를 정의하지 않은 것 등)도 포함. 
- **메시지 요약**
    - 단순히 “코드 레벨에서 shift-left” 하는 것을 넘어서,  
        **요구사항 작성, 아키텍처 설계 단계부터 Secure by Design을 실천해야 한다**는 메시지. 
- **주요 CWE 예시**
    - CWE-256 Unprotected Storage of Credentials
    - CWE-269 Improper Privilege Management
    - CWE-434 Unrestricted Upload of File with Dangerous Type
    - CWE-501 Trust Boundary Violation
    - CWE-522 Insufficiently Protected Credentials 등. 

## 2. 점수표 (Score table)

|항목|값|
|||
|매핑된 CWE 개수|39|
|최대 발생률(Max Incidence)|22.18%|
|평균 발생률(Avg Incidence)|1.86%|
|최대 커버리지(Max Coverage)|88.76%|
|평균 커버리지(Avg Coverage)|35.18%|
|가중 Exploit 점수 평균|6.96|
|가중 Impact 점수 평균|4.05|
|총 발생 건수|729,882|
|관련 CVE 개수|7,647|

**해석 포인트:**
- 평균적으로 **1.86%**의 애플리케이션이 Insecure Design 관련 CWE를 최소 하나 포함.
- 총 발생 건수(약 73만 건)와 CVE(7,600+개)를 보면,  
    “**꽤 자주 등장하지만, 다른 상위 항목에 비해 상대적인 위치가 조금 내려갔다**” 정도로 볼 수 있음.



## 3. 설명 (Description)

### 3-1. Insecure Design이란?

- **정의**
    
    - “**누락되었거나, 제대로 설계되지 않은 보안 통제(missing or ineffective control design)**”를 담는 **넓은 범주의 약점**. 
        
    - “모든 다른 Top 10 항목의 근원”은 아니며,  
        **설계 단계에서의 문제를 따로 떼어 보자**는 취지.
        
- **설계 결함 vs 구현 결함** 
    
    - _Insecure Design_과 _Insecure Implementation_은 명확히 구분.
        
        - 둘은 **원인, 시점, 해결 방법이 완전히 다르다**.
            
    - **Secure design + buggy code**
        
        - 설계는 괜찮은데 구현에서 버그가 나면, 코드 수정으로 해결 가능.
            
    - **Insecure design + perfect code**
        
        - 설계 자체에 필요한 보안 통제가 **아예 존재하지 않기 때문에**,  
            아무리 코드를 잘 짜도 구조적으로 막을 수 없음.
            
    - 즉, **설계를 잘못하면 “패치”로는 안 되는 클래스의 문제가 된다**.
        
- **왜 생기는가?**
    
    - 개발 중인 소프트웨어/시스템에 대해 **비즈니스 리스크 프로파일링**을 제대로 하지 않아서,
        
        - 어느 정도 수준의 보안 설계가 필요한지 판단하지 못하고,
            
        - 그 결과, 애초에 설계 단계에서 보안 요구사항이 빠지는 경우가 많음. 
            

### 3-2. Secure Design의 세 가지 축

OWASP는 “Secure Design”을 다음 세 부분으로 나눔: 

1. **요구사항 수집 & 리소스 관리 (Requirements & Resource Management)**
    
    - 비즈니스와 함께 **요구사항·비즈니스 로직·보호 수준(기밀성, 무결성, 가용성, 진정성)**을 명확히 합의.
        
    - 애플리케이션 노출 수준(공개 서비스인지, 내부망인지 등)과 테넌트 분리 필요성을 고려.
        
    - 보안 활동(설계·테스트·운영 포함)을 포함한 **예산/리소스 계획**을 수립. 
        
2. **보안 설계(Secure Design)**
    
    - 지속적으로 위협을 평가하고, **알려진 공격 기법에 견딜 수 있도록 설계/테스트하는 문화와 방법론**.
        
    - 스프린트 refinement나 유사 활동에 **threat modeling을 통합**하고,
        
        - 데이터 흐름, 접근 통제, 기타 보안 통제의 변경사항을 적극적으로 검토.
            
    - User story 작성 시
        
        - 정상 플로우뿐 아니라 **실패/예외 플로우**도 정의하고
            
        - 가정과 조건을 명확히 문서화.
            
    - “Secure design은 나중에 붙이는 add-on도, 특정 툴도 아니다”라는 점을 강조. 
        
3. **Secure Development Lifecycle (SDL)**
    
    - 보안 개발 생명주기, 보안 설계 패턴, paved road(검증된 공통 컴포넌트),  
        적절한 툴링, threat modeling, 사고 후 post-mortem 등을 포함하는 **프로세스 전체**.
        
    - 프로젝트 초기에, 진행 중에, 유지보수 단계에도 **AppSec 전문가와 긴밀히 협업**할 것을 권장. 
        
    - 필요 시 **OWASP SAMM** 같은 성숙도 모델을 활용해서 조직의 SDL을 구조화. 
        

## 4. 예방 (How to prevent)

1. **보안 개발 생명주기(SDLC) 정립**
    - AppSec 전문가가 참여하는 **Secure SDLC**를 조직 차원에서 정의하고 사용.
    - 설계·개발·테스트·운영의 각 단계에서 **보안/프라이버시 관련 통제를 설계·검토**.
2. **보안 설계 패턴 / Paved Road 확보*
    - 검증된 **보안 설계 패턴, 공통 컴포넌트(paved road)** 라이브러리를 만들어 재사용.
    - 개발자가 “그냥 쓰기만 해도 기본 보안이 담보되는 길”을 제공.
3. **위협 모델링(threat modeling) 정례화**
    - 인증, 접근 통제, 핵심 비즈니스 로직, 주요 플로우 등에 대해  
        정기적으로 **threat modeling** 수행.
    - 데이터 흐름, 역할·권한, 경계(Trust boundary)를 설계 단계에서 점검.
4. **User Story에 보안 언어 녹이기**
    - User story, 요구사항 문서에 **보안 요구사항/플로우/실패 케이스**를 명시적으로 포함.
    - 단순 기능 설명이 아니라 “이 플로우가 공격되면 어떻게 되는지”까지 포함.
5. **각 계층의 Plausibility Check**
    - 프론트엔드 → 백엔드 → DB 등 **각 계층마다 이상 징후 체크**(입력 값, 액션 빈도, 상태 변화 등)를 설계에 포함.
6. **테스트로 Threat Model 검증**
    - 단위/통합 테스트를 통해,  
        **중요 플로우가 Threat Model에 정의된 공격 벡터에 견디는지** 검증.
    - 각 계층에 대해 use-case와 misuse-case를 모두 준비해서 테스트.
7. **계층/테넌트 분리**
    - 노출도와 보호 필요 수준에 따라 **시스템/네트워크 계층을 분리(segregation)**.
    - 멀티 테넌트 서비스라면, **테넌트 분리를 설계 단계에서부터 강하게 반영**.

## 5. 예시 공격 시나리오 (Example attack scenarios)
### 시나리오 #1 – 취약한 비밀번호 찾기(질문·답변 기반 복구) 

- 어떤 서비스의 **계정 복구 플로우**가 여전히 “비밀 질문/답변(Q&A)”에 의존하고 있다고 하자.
- 하지만 NIST 800-63b, OWASP ASVS, OWASP Top 10 모두  
    **질문·답변 방식은 신뢰할 수 있는 신원 증명 수단이 아니므로 금지**하고 있다.
    - 여러 사람이 답을 알 수도 있고,
    - 소셜 미디어/OSINT로 쉽게 유추 가능.
- 이런 복구 설계는 구조적으로 위험하며,  
    **설계 자체를 제거하고 더 안전한 복구 방식(예: 이메일/기기 기반 강한 인증)** 으로 바꿔야 한다.
→ “설계를 잘못 잡은 탓에, 구현을 아무리 깔끔하게 해도 근본적으로 안전해질 수 없는” 대표 사례.

### 시나리오 #2 – 영화관 단체 예매 로직 악용 

- 한 **영화관 체인**이 그룹 예매 
    - 15명까지는 보증금 없이 할인 예매 가능,
    - 그 이상은 **보증금**을 요구하는 정책을 갖고 있다고 가정.
- 공격자가 이 **비즈니스 로직을 Threat Modeling** 하면서    
    - “한 번에 600석, 모든 상영관을 동시에 예약하는 요청” 같은 **극단적인 케이스**를 시도.
- 만약 설계 단계에서
    - “한 계정/세션/시간당 최대 예약 수량” 같은 제약을 안 넣어두었다면,
    - 소수 요청만으로 수백 석을 잠가버려 **대규모 매출 손실**을 초래할 수 있음.
→ **“이런 상황은 안 일어날 거야”라고 간주하고 설계에서 상태/제약을 정의하지 않은 것 자체가 Insecure Design.**

### 시나리오 #3 – GPU 품귀 현상을 악화시키는 봇 공격 

- 한 **전자제품 소매 체인**의 쇼핑몰이
    - 고가 GPU를 판매하는데,
    - **봇/스캐퍼(scalper)에 대한 보호 설계가 전혀 없다.**
- 공격자들은 봇을 사용해
    - 제품이 풀리자마자 수 초 내에 싹쓸이 구매 →  
        중고/경매 사이트에 고가로 되팔이.
- 결과:
    - GPU 제조사와 소매점 모두 **이미지 타격**,
    - 정가로 사고 싶은 일반 고객은 **물건을 아예 구하지 못함**.
- 설계 단계에서
    - IP/계정당 구매 제한,
    - 비정상적인 구매 패턴에 대한 탐지/차단,
    - Queue 기반 판매, Captcha/봇 탐지  
        등의 **도메인 로직 + 보안 설계**를 넣었어야 했음.
→ 여기서도 문제는 코드 버그가 아니라 **“처음부터 이런 상황을 고려하지 않은 설계”** 에 있음.