# Cryptographic Failures
## 1. 배경 (Background)

- 2021년에는 상위권이었는데, 2025 RC1에서 **#2 → #4**로 두 단계 내려갔습니다.
- 다루는 범위:
    - **암호화를 아예 안 쓰는 경우**
    - **약한 알고리즘·키·프로토콜 사용**
    - **키 유출 및 키 관리 실패**
    - **취약한 난수 생성(PRNG, entropy 부족 등)**
- 대표적으로 많이 등장한 CWE:
    - CWE-327: 깨진/위험한 암호 알고리즘 사용
    - CWE-331, CWE-330 계열: entropy 부족, 예측 가능한 난수
    - CWE-338, CWE-1241: 암호학적으로 약한 PRNG 사용 

요약하면, **암호 그 자체보다는 “암호를 잘못 적용한 케이스들”** 이 매우 흔하고 치명적이라서 별도 카테고리로 유지되고 있습니다.

## 2. 점수표 (Score table)

OWASP Top 10 데이터 집계 기준 점수표는 다음과 같습니다: 

|항목|값|
|-|---|
|매핑된 CWE 개수|32개|
|최대 발생률(Max Incidence)|13.77%|
|평균 발생률(Avg Incidence)|3.80%|
|최대 커버리지(Max Coverage)|100.00%|
|평균 커버리지(Avg Coverage)|47.74%|
|가중 Exploit 점수 평균|7.23|
|가중 Impact 점수 평균|3.90|
|총 발생 건수|1,665,348|
|관련 CVE 개수|2,185|

해석:
- **3.80% 애플리케이션**이 이 카테고리의 취약점을 최소 1개 이상 가지고 있다는 뜻이고,
- 관련 CVE도 **2천 개 이상**이라, 실무에서 매우 자주 마주치는 문제라는 걸 보여줍니다

## 3. 설명 (Description)

OWASP 설명을 정리하면, 핵심 포인트는 다음과 같습니다. 

1. **전송 중 데이터(데이터 in transit)**
    - 모든 전송 데이터는 **전송 계층(OSI 4계층)에서 TLS 등으로 암호화**하는 것이 기본 전제.
    - 예전에는 CPU 부하, 인증서 관리가 어려웠지만,
- CPU의 **AES 가속 명령어**
- Let’s Encrypt 같은 **자동 인증서 발급/갱신 서비스**
- 클라우드 벤더의 인증서 관리  
    덕에 지금은 “안 해서 그렇지, 못 해서가 아니다”라는 포지션.
1. **저장 데이터(데이터 at rest) & 추가 암호화**
    - 비밀번호, 카드번호, 의료정보, 개인정보, 기업 기밀 등은
- 저장 시 암호화
- 전송 시에도 **애플리케이션 레벨 추가 보호**가 필요할 수 있음(GDPR, PCI DSS 등 규제와도 직접 연결).
1. 설계/구현에서 점검해야 할 대표적인 질문들:
    - **약한/구식 알고리즘·프로토콜**(예: MD5, SHA-1, 취약한 TLS 버전)을 쓰고 있지는 않은가?
    - **기본 키, 약한 키, 키 재사용, 키 회전 미비** 문제는 없는가?
    - **암호 키를 Git 등 소스 저장소에 커밋**해버린 적은 없는가?
    - HTTPS를 쓰더라도:
- **HSTS·보안 헤더 미설정** 등으로 암호화를 강제하지 않고 있지는 않은가?
- 서버 인증서·체인 검증을 제대로 하고 있는가?
    - **IV/Nonce 재사용**, insecure 모드(ECB 등) 사용, AEAD 미사용 등으로  
암호 모드 운용을 잘못 하고 있지는 않은가?
    - **비밀번호를 그대로 키로 사용**하면서 PBKDF를 쓰지 않는 케이스는 없는가?
    - **난수 생성** 시, 암호용이 아닌 RNG를 사용하거나,  
개발자가 직접 seed를 잘못 셋팅해서 entropy를 망치지는 않았는가?
    - **MD5/SHA1 같은 폐기된 해시**, 오래된 padding 방식(PKCS#1 v1.5 등)을 아직도 사용하는 부분은 없는가?
    - **Padding oracle** 같은 사이드 채널을 유발하는 에러 메시지를 노출하지 않는가?
    - **알고리즘 다운그레이드 공격**에 취약한 프로토콜 구성을 사용하지 않는가?

한 줄로 요약하면, _“알고리즘 선택, 키 관리, 난수, 프로토콜 설정, 에러 처리”_ 다섯 축에서의 실수가 Cryptographic Failures를 만든다고 보면 됩니다.

## 4. 예방 방법 (How to prevent)

OWASP가 제안하는 최소한의 예방 수칙을 한국어로 정리하면: 

1. **데이터 분류 & 라벨링**
    - 애플리케이션이 처리/저장/전송하는 데이터를 분류하고,
	- 어떤 데이터가 법·규제·비즈니스 상 민감한지 명확히 라벨링.
2. **키 관리 강화**
    - **가장 민감한 키는 HSM(하드웨어/클라우드 기반)**에 저장.
    - 키는 **암호학적 난수**로 생성하고, 주기적인 **회전 정책**을 적용.
    - 키/비밀을 절대 **소스 코드·Repo에 커밋**하지 않기(Secrets Manager 사용).
3. **검증된 라이브러리 사용**
    - 직접 “알고리즘 구현”하지 말고,
	- 검증된 표준 라이브러리/프레임워크를 사용.
    - 프레임워크 기본값이 안전한지 확인(예: TLS 설정, default cipher suite 등).
4. **데이터 최소화**
    - 민감 데이터를 **필요 이상 저장하지 않기**.
    - 가능하면 **토큰화(tokenization)/마스킹/부분 저장(truncation)**을 적용.  
	→ _없으면 털릴 것도 없다._
5. **암호화 적용 범위를 넓게**
    - **저장 데이터:** DB, 파일, 백업 등에 대해 암호화 적용.
    - **전송 데이터:**
		- TLS(Forward secrecy 지원 cipher) 필수
		- 서버 우선 cipher 선택
		- HSTS로 HTTPS 강제
    - **민감 응답 캐싱 금지:**
		- CDN, 웹서버, 애플리케이션 캐시(예: Redis) 모두 포함.
6. **프로토콜 선택**
    - FTP, 평문 SMTP 등 **암호화되지 않은 프로토콜 사용 금지**,
		- FTPS/SFTP, SMTPS/TLS 등으로 대체.
7. **비밀번호 저장**
    - Argon2, scrypt, bcrypt(레거시), PBKDF2-HMAC-SHA-256 같은  
		**적응형 + Salt + Work factor**가 있는 해시 함수 사용.
    - Work factor는 하드웨어 성능에 맞춰 **충분히 느리게** 설정.
8. **IV/Nonce 및 모드 운용**
    - CBC 등 각 모드에 맞는 **IV/Nonce 정책** 준수:
		- CSPRNG로 생성하거나
		- Nonce 재사용 금지 등.
	    - 가능하면 **AEAD(GCM, ChaCha20-Poly1305 등)** 사용.
9. **난수 생성**
    - 항상 **CSPRNG** 사용, 직접 seed를 건드리지 말 것.
    - 엔트로피 부족/예측 가능한 seed 금지.
10. **Deprecated 기능 제거**
    - MD5, SHA1, 오래된 RSA padding, CBC+예측 가능한 IV 등  
		**더 이상 권장되지 않는 알고리즘/모드를 제거**.
    - 설정/구성은 보안 전문가나 전용 도구로 리뷰.
11. **Post-Quantum 준비**
    - ENISA, NIST 가이드 등을 참고해 **양자내성 암호(PQC)** 전환 로드맵을 고려.

## 5. 예시 공격 시나리오 (Example attack scenarios)
### 시나리오 #1 – TLS 미사용·약한 암호화로 인한 세션 탈취 

1. 웹 사이트가 전체 페이지에 대해 HTTPS를 강제하지 않거나,  
    **약한 암호 스위트/프로토콜**을 허용한다.
2. 공격자는 공용 와이파이 등에서 트래픽을 모니터링하면서
    - HTTPS를 HTTP로 **다운그레이드**하거나,
    - 중간자 공격으로 세션 쿠키를 훔친다.
3. 탈취한 세션 쿠키를 재사용해 **사용자 세션을 하이재킹**하고,
    - 개인정보 조회/수정,
    - 송금 수신 계좌 조작 등 모든 작업을 사용자인 척 수행한다.
→ “**HTTPS만 쓰면 안전**”이 아니라, **강제(HSTS) + 강한 Cipher + 올바른 설정**이 필요하다는 예.

### 시나리오 #2 – 약한 비밀번호 해싱 & 해시 유출 

1. 서비스가 사용자 비밀번호를
    - **Salt 없이** 또는
    - MD5 같은 **빠르고 약한 해시**로만 저장한다.
2. 파일 업로드 취약점 등으로 인해 공격자가 **비밀번호 DB 파일을 다운로드**한다.
3. 공격자는
    - 미리 계산된 **레인보우 테이블**을 사용하거나,
    - GPU로 대량 **브루트 포스/딕셔너리 공격**을 수행하여
    - 해시 대부분을 단시간에 평문 비밀번호로 복구한다.
4. 복구된 비밀번호로 계정 탈취, 다른 서비스 재사용 공격(credential stuffing)까지 이어질 수 있다.
→ 비밀번호 해싱을 **잘못** 하는 순간, DB가 한 번만 유출돼도 **사실상 모든 계정이 털리는 상황**이 됨.