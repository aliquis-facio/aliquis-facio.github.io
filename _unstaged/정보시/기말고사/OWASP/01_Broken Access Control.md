# Broken Access Control
## 1. 배경 (Background)

- **순위**: OWASP Top 10:2025에서 A01은 2021에 이어 **계속 1위 유지**.
- **의미**: 전체 애플리케이션 100%에서 어떤 형태로든 **Broken Access Control이 테스트 대상**이 되었고, 이 카테고리는 **가장 많은 발생 건수**와 **두 번째로 많은 CVE 수**를 보유함.
- **핵심 위험**: 접근 제어 실패는
    - 권한 없는 사용자의 **민감 정보 열람**,
    - 데이터의 **무단 수정·삭제**,
    - 사용자가 허용된 범위를 넘는 **비즈니스 기능 수행**으로 이어질 수 있음.
- **대표 CWE** (A01 범주에 포함되는 대표적인 약점들):
    - **CWE-200** – Exposure of Sensitive Information to an Unauthorized Actor
    - **CWE-201** – Exposure of Sensitive Information Through Sent Data
    - **CWE-352** – Cross-Site Request Forgery (CSRF)
    - **CWE-918** – Server-Side Request Forgery (SSRF)
    - **CWE-284** – Improper Access Control
    - **CWE-285** – Improper Authorization
 
## 2. Score table (점수 표)

| 항목                     | 값         |
| ---------------------- | --------- |
| 매핑된 CWE 수              | 40        |
| 최대 발생률 (Max Incidence) | 20.15%    |
| 평균 발생률 (Avg Incidence) | 3.74%     |
| 최대 커버리지 (Max Coverage) | 100.00%   |
| 평균 커버리지 (Avg Coverage) | 42.93%    |
| 가중 평균 Exploit 점수       | 7.04      |
| 가중 평균 Impact 점수        | 3.84      |
| 총 발생 건수                | 1,839,701 |
| 총 CVE 수                | 32,654    |

정량 지표를 종합하면, **Broken Access Control은 발생 빈도 자체도 매우 높고(가장 많은 발생 건수), 공격자가 악용하기도 쉬우며(Exploit 점수 높음), 실제 영향(Impact)도 상당히 큰 핵심 위험 영역**임을 알 수 있습니다. 또한 100%까지 도달한 Max Coverage는, 대부분의 애플리케이션이 이 영역에 대해 **어떤 형태로든 점검·테스트를 수행하고 있으며, 그만큼 현실적인 위협으로 인식되고 있다**는 점을 보여 줍니다.

## 3. 위험 설명 (Description)

접근 제어(Access Control)는 사용자가 **자신에게 허용된 권한 범위 내에서만** 행동하도록 정책을 강제하는 메커니즘이다. 이 메커니즘이 깨지면,
- 권한 없는 정보 열람(정보 노출),
- 데이터의 무단 수정·삭제,
- 사용자의 권한을 넘어서는 비즈니스 기능 수행(예: 일반 사용자가 관리자 기능 수행) 등으로 직결된다.

1. **최소 권한 원칙(deny by default) 위반**
    - 기본이 “허용”인 설계로 인해, 특정 역할/권한/사용자에게만 허용되어야 할 기능이나 데이터가 **모든 사용자에게 열려 있는 경우
    - 예: 인증만 되면 누구나 관리자용 엔드포인트에 접근 가능
2. **URL·파라미터·상태 조작을 통한 접근 제어 우회**
    - URL, 쿼리 파라미터, 숨겨진 필드, 내부 애플리케이션 상태 등을 수정하거나
    - API 요청을 조작하는 도구를 사용해 **백엔드 접근 제어 체크를 우회**하는 경우
    - 예: `role=user` 를 `role=admin` 으로 수정해 보내도 서버에서 검증하지 않음
3. **Insecure Direct Object Reference (IDOR)**
    - 단순히 **다른 사용자의 리소스 ID(계정 번호, 주문 번호 등)를 넣었을 때**, 그 리소스를 열람·수정할 수 있는 경우
    - 예: `?acct=123` → `?acct=124` 로 변경 시 다른 사람 계정 정보가 그대로 조회됨
4. **API 메서드별 접근 제어 누락 (POST/PUT/DELETE)**
    - API가 존재하지만, **읽기(GET)** 이외의 변경 메서드(POST, PUT, DELETE)에 대해 별도의 접근 제어가 없는 경우
    - 결과적으로 누구나 레코드를 생성·수정·삭제할 수 있게 됨
5. **권한 상승(Elevation of Privilege)**
    - 로그인하지 않은 상태에서 특정 사용자인 것처럼 행동하거나,
    - 일반 사용자 계정으로 로그인했음에도 **관리자 권한 기능을 수행할 수 있는 경우**
6. **JWT·쿠키·메타데이터 조작**
    - JWT(access token), 세션 쿠키, 숨겨진 필드 등 **권한 정보를 담은 메타데이터를 재사용·위조·변조**하여 권한을 상승시키는 경우
    - 예: JWT 서명 검증 미비, 만료·폐기 로직 미흡 등으로 인한 토큰 남용
7. **CORS 오구성(Misconfiguration)**
    - Access-Control-Allow-Origin 등을 잘못 설정하여, **신뢰되지 않은 오리진에서 민감 API에 접근**할 수 있게 되는 경우
8. **Force Browsing (강제 탐색)**
    - 인증되지 않은 사용자가 인증이 필요한 페이지에,
    - 일반 사용자가 관리자 페이지에
    - **URL 추측·브루트포스를 통해 직접 접근**할 수 있는 경우

이러한 취약점들은 대부분 **서버 측 접근 제어 검증이 부족하거나, 신뢰할 수 없는 클라이언트(브라우저/앱)에 접근 제어를 위임한 설계**에서 발생한다.

## 4. 예방 방법 (How to prevent)

접근 제어는 **공격자가 수정할 수 없는 신뢰할 수 있는 서버 측 코드(또는 서버리스 API)** 에서 구현할 때만 효과적이다. 주요 예방 방법은 다음과 같다:

1. **서버 측 중심의 접근 제어 구현**
    - 접근 제어 체크와 권한 정보는 반드시 **서버 측**에서 처리
    - 클라이언트(Javascript, 모바일 앱)에만 의존한 접근 제어는 금지
2. **기본 거부(Deny by Default) 원칙 적용**
    - 공개 리소스를 제외하고는 **기본은 거부, 명시적으로 허용된 것만 허용**
    - 역할·권한·소유자 등 조건을 만족해야만 접근 가능하게 설계
3. **접근 제어 메커니즘의 중앙화·재사용**
    - 애플리케이션 전역에서 재사용 가능한 **공통 접근 제어 모듈** 또는 정책 엔진 활용
    - 중복·우회 지점이 발생하지 않도록, 각 컨트롤러/핸들러마다 제각각 구현하지 않기
    - CORS 사용은 최소화하고, 반드시 필요한 경우에만 엄격히 설정
4. **레코드 소유권(Record Ownership) 기반 모델
    - 사용자가 CRUD 가능한 레코드 범위를 **“소유권(Owner)” 기준으로 제한**
    - 예: `user_id` == `session_user_id` 인 레코드만 조회·수정 가능
5. **비즈니스 한도(Business Limits) 강제**
    - 도메인 모델 수준에서 **일일 한도, 최대 금액, 최대 건수 등 비즈니스 한도**를 강제
    - 단순 UI 체크가 아니라 서버 측에서 반드시 검증
6. **디렉터리 리스팅·메타데이터 노출 방지**
    - 웹 서버 디렉터리 리스트를 비활성화
    - `.git`, 백업 파일, 설정 파일 등 **민감 메타데이터와 백업 파일을 웹 루트 밖**으로 이동
7. **접근 제어 실패 로깅 및 알림**
    - 접근 거부·권한 부족, 반복적인 권한 상승 시도 등은 **로그로 남기고 필요 시 관리자에게 알림**
    - A09(Logging & Alerting Failures)와 연계된 영역
8. **API 및 컨트롤러 Rate Limiting**
    - 자동화된 공격 툴로 인한 URL 브루트포스, IDOR 시도 등을 완화하기 위해
    - API/컨트롤러에 **속도 제한(rate limit)** 적용
9. **세션·JWT 수명 및 폐기 전략**
    - 상태 기반 세션 ID는 로그아웃 시 서버에서 즉시 무효화
    - JWT는 **짧은 수명**을 권장하며, 장기 토큰을 사용할 경우 OAuth 표준에 따른 **토큰 폐기·철회(Revocation)** 기능 구현
10. **검증된 접근 제어 프레임워크·패턴 활용**
    - 직접 모든 접근 제어를 새로 만드는 대신,
    - 검증된 **권한 프레임워크(ACL, RBAC, ABAC 등)** 와 선언적(Declarative) 접근 제어 패턴 활용
11. **테스트에 접근 제어 시나리오 포함**
    - 개발자·QA는 기능 테스트뿐 아니라,
    - **권한 우회, IDOR, Force Browsing, CORS 오구성 등**을 유닛·통합 테스트에 포함해야 함

## 5. 예시 공격 시나리오 (Example attack scenarios)
### 시나리오 1 – 계정 파라미터 조작을 통한 다른 사용자 계정 열람 (IDOR)

한 애플리케이션은 계정 정보를 조회하기 위해, 클라이언트에서 넘어온 `acct` 파라미터를 그대로 SQL 쿼리에 사용한다.  
서버는 `acct` 값이 현재 로그인한 사용자 소유인지 검증하지 않기 때문에, 공격자는 브라우저 주소창의 `acct` 값을 다른 번호로 바꾸기만 해도 **임의의 사용자의 계정 정보에 접근**할 수 있다.

예를 들어:
- 정상 요청: `https://example.com/app/accountInfo?acct=myacct`
- 공격 요청: `https://example.com/app/accountInfo?acct=notmyacct`

이 경우, 접근 제어가 레코드 소유권 기준으로 구현되어 있지 않기 때문에, 공격자는 단순 파라미터 변경만으로 다른 사용자의 민감 데이터를 열람할 수 있게 된다.

### 시나리오 2 – 관리자 페이지 URL 강제 접속(Force Browsing)

동일한 애플리케이션에 다음 두 URL이 존재한다고 하자.
- 일반 정보 페이지: `/app/getappInfo`
- 관리자 정보 페이지: `/app/admin_getappInfo`

이때 애플리케이션이 **URL에 대한 별도의 권한 체크를 수행하지 않는다면**, 공격자는 단순히 브라우저나 스크립트로 관리자용 URL을 직접 호출함으로써 인증되지 않은 상태에서 관리자 기능에 접근하거나, 일반 사용자 계정으로 로그인한 상태에서 관리자용 API를 호출할 수 있다.

즉, “URL만 안 알리면 된다”는 식의 보안(보안과 through obscurity)에 의존할 경우, 단순 **URL 추측·브루트포스만으로 관리자 기능이 노출**될 수 있다는 것을 보여 주는 사례이다.

### 시나리오 3 – 프론트엔드 기반 접근 제어의 우회

어떤 애플리케이션은 “보안은 모두 프론트엔드에서 처리된다”고 믿고, 관리자 페이지 링크를 자바스크립트 조건문으로 숨겨 두었다고 가정해 보자.

브라우저에서는 일반 사용자가 관리자 메뉴를 볼 수 없지만, 실제 관리자용 API 엔드포인트(예: `/app/admin_getappInfo`)는 **백엔드에서 누구에게나 열려 있는 상태**이다.  
공격자는 브라우저가 아니라, 커맨드라인에서 단순히 다음과 같이 호출해 버릴 수 있다.

- `curl https://example.com/app/admin_getappInfo`

이 경우, 프론트엔드 코드가 아무리 “관리자만 볼 수 있다”고 주장해도, 실제 접근 제어가 서버 측에서 구현되어 있지 않기 때문에 **누구나 관리자 기능에 접근하는 Broken Access Control** 상황이 발생한다.

---

## 참고

- [OWASP Foundation – A01:2025 Broken Access Control](https://owasp.org/Top10/2025/A01_2025-Broken_Access_Control/ "A01 Broken Access Control - OWASP Top 10:2025")