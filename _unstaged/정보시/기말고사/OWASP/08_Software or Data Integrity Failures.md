# Software or Data Integrity Failures
## 1. 배경 (Background)

- **순위 변화 / 위치**
    
    - 2021에 새로 등장했던 항목이었고, 2025 RC1에서도 그대로 **#8** 위치를 유지합니다. 
        
- **이름 변화**
    
    - 2021: _Software and Data Integrity Failures_
        
    - 2025: _Software or Data Integrity Failures_  
        → 의도를 더 분명히 하려는 **미세한 이름 정제** 수준입니다. 
        
- **포커스(어디를 다루는가)**
    
    - **신뢰 경계를 유지하지 못하고**, 소프트웨어/코드/데이터 아티팩트의 **무결성 검증을 하지 않는 실패**에 초점을 둡니다.
        
    - A03 Software Supply Chain Failures보다 **더 로우 레벨**에서,
        
        - 업데이트,
            
        - 플러그인/라이브러리/모듈,
            
        - 직렬화된 데이터  
            같은 것을 **“검증 없이 신뢰해버리는 가정”**에 주목합니다. 
            
- **대표 CWE 예시** 
    
    - CWE-829: Untrusted Control Sphere에서 기능 포함
        
    - CWE-915: 동적으로 결정되는 객체 속성의 잘못된 수정 제어
        
    - CWE-502: 신뢰할 수 없는 데이터의 역직렬화
        



## 2. 점수표 (Score table)

2025 RC1 데이터 기준 지표는 다음과 같습니다. 

|항목|값|
|---|---|
|매핑된 CWE 개수|14|
|최대 발생률(Max Incidence)|8.98%|
|평균 발생률(Avg Incidence)|2.75%|
|최대 커버리지(Max Coverage)|78.52%|
|평균 커버리지(Avg Coverage)|45.49%|
|가중 Exploit 점수 평균|7.11|
|가중 Impact 점수 평균|4.79|
|총 발생 건수|501,327|
|관련 CVE 개수|3,331|

**해석 포인트**

- 분석 대상 앱 중 **약 2.75%**가 해당 CWE를 최소 하나 포함.
    
- CVE도 **3천 개+** 수준이라, 공급망만큼 화제는 아니더라도 **실전에서 꽤 자주 터지는 무결성 관련 문제**라는 걸 보여줍니다.
    



## 3. 설명 (Description)

### 3-1. 개념 정리

> **신뢰할 수 없는 코드·데이터를 “신뢰 가능한 것처럼” 다루도록 만드는 설계·구현 문제**를 묶은 카테고리.

OWASP 설명을 정리하면: 

- 애플리케이션 코드/인프라가
    
    - **위·변조되었거나**,
        
    - 출처가 불분명한 코드·데이터를  
        **검증 없이 신뢰**할 때 발생.
        
- 대표적인 예:
    
    1. **플러그인/라이브러리/모듈을 불신뢰 출처에서 가져옴**
        
        - 검증되지 않은 CDN, 랜덤 Git 리포지터리 등.
            
    2. **무결성 검증이 없는 CI/CD 파이프라인**
        
        - 외부에서 가져온 코드/아티팩트에 대해  
            서명/해시 기반 검증 없이 빌드·배포에 사용.
            
    3. **서명 검증 없이 자동 업데이트**
        
        - 클라이언트/펌웨어가 업데이트를 다운로드하면서  
            “이게 진짜인지, 중간에 바뀐 건 아닌지” 확인하지 않고 설치.
            
    4. **취약한 직렬화/역직렬화 설계**
        
        - 공격자가 볼 수 있고 수정할 수 있는 형태로 객체/데이터를 직렬화하고,  
            이를 다시 역직렬화하여 신뢰된 코드에서 실행하는 패턴  
            → 전형적인 **insecure deserialization** 케이스.
            

즉, **“출처/무결성 검증 없이 뭔가를 믿고 있는 모든 지점”**이 다 이 카테고리에 들어간다고 보면 됩니다.



## 4. 예방 방법 (How to prevent)

OWASP에서 제시하는 예방 지침을 요약하면 다음과 같습니다. 

1. **디지털 서명/무결성 검증 필수화**
    
    - 소프트웨어·업데이트·중요 데이터에 대해
        
        - 코드 서명,
            
        - 해시 + 서명,
            
        - 기타 무결성 검증 메커니즘  
            을 사용해 **출처와 변경 여부를 검증**.
            
    - 예: 패키지 서명 검증, 컨테이너 이미지 서명 등.
        
2. **신뢰할 수 있는 저장소만 사용**
    
    - npm, Maven, PyPI 등 **공식/신뢰된 리포지터리만 사용**.
        
    - 보안 요구 수준이 높은 조직은
        
        - 직접 **내부 미러/내부 아티팩트 저장소**를 운영하고,
            
        - 거기에는 **검증된 아티팩트만 올라오도록 리뷰·정책** 적용.
            
3. **코드·설정 변경에 대한 리뷰 프로세스**
    
    - 코드 뿐 아니라 **빌드 스크립트, IaC, CI/CD 설정**까지  
        변경 시 **리뷰·승인 절차**를 거치게 해서  
        악성 코드나 잘못된 설정이 **파이프라인에 섞이지 않도록**.
        
4. **CI/CD 파이프라인 보안 강화**
    
    - 빌드·배포 파이프라인에 대해:
        
        - 권한 분리(segregation),
            
        - 최소 권한 원칙,
            
        - 접근 제어,
            
        - 비밀·토큰 관리  
            를 제대로 적용해 **코드 흐름의 무결성**을 보호.
            
    - “누구나 빌드 서버에 들어가서 스크립트 수정 가능” 상태는 절대 금지.
        
5. **직렬화된 데이터에 대한 무결성 보호**
    
    - **서명되지 않았거나 암호화되지 않은 직렬화 데이터**를  
        불신뢰 클라이언트로부터 받아서 그대로 사용하는 패턴을 피함.
        
    - 어쩔 수 없는 경우:
        
        - 데이터에 **서명/무결성 체크**를 붙이고,
            
        - 재생(replay) 공격·변조를 감지할 수 있도록 설계. 
            
6. **쿠키·세션 토큰 무결성**
    
    - 쿠키에 의존할 때는
        
        - 무결성 검증(서명, MAC 등) 없이 신뢰하지 않도록 설계  
            (관련 CWE-565, CWE-784). 
            



## 5. 예시 공격 시나리오 (Example attack scenarios)

### 시나리오 1 – 서드파티 지원 도메인으로 인한 세션 탈취

- 한 회사가 **외부 고객지원 서비스 업체**를 사용하면서,  
    편의상 `support.myCompany.com`을 **서드파티 업체 도메인으로 CNAME 매핑**해 둔다.
    
- 결과적으로, `myCompany.com` 도메인에 설정된 **모든 쿠키(세션 쿠키 포함)**가  
    `support.myCompany.com` 접속 시 **서드파티 인프라로 전송**된다. 
    
- 지원 업체 인프라에 접근 가능한 내부자나 공격자는
    
    - 이 쿠키들을 훔쳐서
        
    - **세션 하이재킹(로그인 세션 탈취)**을 수행할 수 있다.
        

→ 웹 기능(스크립트/도메인/리디렉션 등)을 **불신뢰 소스에 포함시킨 설계 자체**가 문제인 케이스.



### 시나리오 2 – 서명 없는 펌웨어/패키지 업데이트

1. 여러 **홈 라우터, 셋톱박스, IoT 장비**가
    
    - 펌웨어 업데이트를 **서명 검증 없이** 다운로드해 바로 적용한다. 
        
2. 공격자가
    
    - 악성 펌웨어 이미지를 업로드하거나,
        
    - 유통 경로를 오염시켜  
        **조작된 펌웨어가 정상 업데이트인 것처럼 배포**되게 만든다.
        
3. 장비는 이를 정상 업데이트로 믿고 설치 →
    
    - 대량의 장비가 봇넷, 백도어 등으로 오염.
        
4. 많은 경우 **롤백/복구 메커니즘도 부실**해서,
    
    - 새 버전이 배포될 때까지 오염 상태를 견디는 수밖에 없다.
        

또 다른 변형: 

- 개발자가 패키지 매니저에서 원하는 버전을 못 찾자
    
    - 아무 웹사이트에서 해당 패키지를 직접 다운로드.
        
    - 서명/해시 검증도 없이 프로젝트에 포함.
        
- 이 패키지에 **악성 코드가 포함**되어,  
    빌드/운영 환경에서 원격 코드 실행, 정보 유출 등이 발생.
    



### 시나리오 3 – Java 역직렬화를 이용한 원격 코드 실행

- React 프런트엔드 + Spring Boot 마이크로서비스 구조의 서비스가 있다.
    
- “상태를 불변(immutable)하게 유지하자”는 아이디어로,
    
    - **사용자 상태 객체를 직렬화해서 요청마다 클라이언트↔서버 간 왕복**시키는 설계를 함.
        
- 공격자가 트래픽을 보다가
    
    - base64 안에 있는 **`rO0` 시그니처(자바 직렬화 헤더)**를 발견. 
        
- `Java Deserialization Scanner` 같은 도구를 사용해
    
    - 역직렬화 payload를 심고,
        
    - 서버에서 **원격 코드 실행(RCE)** 를 얻는 데 성공.
        

→ “직렬화된 객체를 신뢰한다”는 설계 + **무결성 검증 없음**이 합쳐져서 as-is로 RCE까지 가는 전형적인 A08 사례.