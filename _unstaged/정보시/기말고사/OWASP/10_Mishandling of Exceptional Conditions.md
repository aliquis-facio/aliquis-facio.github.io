# Mishandling of Exceptional Conditions
## 1. 배경 (Background)

- **완전히 새로 추가된 카테고리 (2025 New)**
    
    - 2021에는 없었고, 2025에서 처음 등장한 항목. 
        
- **포커스**
    
    - “예외 상황을 어떻게 (못) 처리하느냐”에 대한 카테고리:
        
        - 잘못된/부족한 예외 처리
            
        - 논리 오류
            
        - **Fail Open(안 막고 열려 버리는 실패)**
            
        - 비정상/에러 상황에서 시스템이 이상한 상태로 남는 문제 
            
- **CWEs**
    
    - 총 **24개 CWE** 매핑. 예를 들어: 
        
        - CWE-209: 에러 메시지에 민감 정보 노출
            
        - CWE-234: 누락된 파라미터 처리 실패
            
        - CWE-274: 권한 부족 상태를 제대로 처리하지 못함
            
        - CWE-476: NULL 포인터 역참조
            
        - CWE-636: 안전하게 실패하지 못함(Failing Open)
            
    - 원래 “Poor Code Quality” 같은 너무 넓은 카테고리에 묶여 있던 것들을,  
        **“예외 상황 처리”라는 관점으로 따로 분리**한 것.
        

---

## 2. 점수표 (Score table)

OWASP 데이터 기준 A10의 통계 값은 다음과 같아요. 

|항목|값|
|---|---|
|매핑된 CWE 개수|24|
|최대 발생률(Max Incidence)|20.67%|
|평균 발생률(Avg Incidence)|2.95%|
|최대 커버리지(Max Coverage)|100.00%|
|평균 커버리지(Avg Coverage)|37.95%|
|가중 Exploit 점수 평균|7.11|
|가중 Impact 점수 평균|3.81|
|총 발생 건수|769,581|
|관련 CVE 개수|3,416|

**해석 한 줄 요약:**  
평균 약 3%의 애플리케이션이 예외 처리 관련 취약점을 최소 하나는 가지고 있고,  
실전에서도 수십만 건 이상 관찰된 “꽤 흔한” 문제라는 의미.

---

## 3. 설명 (Description)

### 3-1. 개념

> 프로그램이 **비정상/예외 상황(Exceptional Conditions)** 을 제대로 **예방·탐지·대응하지 못해서** 크래시, 이상 행동, 보안 취약점으로 이어지는 모든 문제. 

- 세 가지 레벨에서 실패할 수 있음: 
    
    1. **예외 상황이 발생하지 않게 하는 예방에 실패**
        
    2. 예외 상황이 발생했는데 **그걸 예외로 인식하지 못함**
        
    3. 예외를 인식했지만 **대응을 잘못하거나 아예 안 함**
        

### 3-2. 어떤 상황에서 생기나?

OWASP가 예로 드는 것들: 

- **입력 검증 미비·불완전**으로 이상한 값이 깊숙이 들어감
    
- 예외가 발생한 **바로 그 위치에서 처리하지 않고**,  
    너무 높은 레벨에서만 뭉뚱그려 처리
    
- 메모리 부족, 권한 부족, 네트워크 장애 등 **환경 상태가 예상 밖인데**,  
    그 상태를 감지/처리하지 않음
    
- 예외 처리 방식이 **일관되지 않거나**,  
    아예 catch를 안 해서 시스템이 **알 수 없는 상태(unknown state)**에 빠짐
    
- “다음 명령을 무엇을 해야 할지 애매한 상태”가 되면  
    이미 예외 상황 처리를 잘못한 것
    

### 3-3. 이로 인해 생기는 취약점

예외 처리를 망하면 아래 같은 것들이 발생할 수 있음: 

- 로직 버그, 오버플로우, 레이스 컨디션
    
- 사기 거래(중간 실패/롤백 실패로 인한 금액 꼬임)
    
- 메모리/상태/자원/타이밍 관련 오류
    
- 인증·인가(Authorization) 오류
    
- 결과적으로 **기밀성·무결성·가용성(CIA)** 어느 쪽이든 깨질 수 있고,  
    공격자는 **엉성한 에러 처리 흐름을 악용해서** 이런 취약점을 터뜨린다.
    

---

## 4. 예방 (How to prevent)

핵심 키워드: **“최악을 가정하고, 발생 지점에서 잡고, 안전하게 실패(Fail Closed)”**. 

### 4-1. 예외 처리 기본 전략

- **최악을 예상(expect the worst)**
    
    - “이 입력·이 상태에서는 절대 이런 일이 안 나겠지”라는 가정을 버리기.
        
- **발생 지점에서 예외를 잡고 처리**
    
    - 가능한 한 **에러가 발생한 함수/모듈 근처에서 catch & handle**
        
    - “의미 있는 조치”를 취해야 함:
        
        - 리소스 정리/롤백
            
        - 유저에게 이해 가능한 에러 메시지
            
        - 이벤트 로그 기록
            
        - 필요하면 알림(Alert) 발행 
            
- **글로벌 예외 처리기(Global Exception Handler)**도 필수
    
    - 혹시 빠져나간 예외를 마지막에라도 잡아서  
        시스템이 완전히 폭주/노출되지 않도록.
        

### 4-2. 모니터링·관찰성(Observability)

- **반복되는 에러 패턴**을 감시할 수 있는  
    모니터링/관찰성(Observability) 도구를 사용:
    
    - 동일 에러가 짧은 시간에 여러 번 발생하면  
        공격/대규모 장애로 판단하고 대응/차단 트리거. 
        
- 같은 에러가 너무 자주 발생하면,
    
    - 로그를 줄이되 **발생 횟수·시간대 통계만 덧붙여 기록**해서  
        SIEM/모니터링 도구에 방해되지 않도록 설계. 
        

### 4-3. 트랜잭션과 Fail Closed

- 트랜잭션 중간에 예외가 발생하면:
    
    - **전체 트랜잭션을 모두 롤백하고 처음부터 다시 시작**
        
    - “중간까지 된 걸 어떻게든 이어서 맞춰보자”는 시도가  
        **상태 꼬임·금전 손실·Race Condition**의 주요 원인. 
        
- 기본 원칙은 **Fail Closed**:
    
    - 뭔가 잘 모르겠으면 “막고(deny)” 다시 시작하는 방향으로 설계.
        

### 4-4. 자원·Rate Limiting

- **Rate Limiting, Quota, Throttling 등 자원 한도**를 가능한 곳마다 적용: 
    
    - 무제한 업로드
        
    - 무제한 API 호출
        
    - 무제한 동시 요청  
        → 이런 것들이 예외 상황/DoS의 주요 원인이 되므로 “무한”은 금지.
        
- 이렇게 해야
    
    - DoS,
        
    - 브루트포스,
        
    - 말도 안 되는 클라우드 요금 폭탄  
        등을 막으면서 **예외 상황 자체를 덜 만들 수 있음**.
        

### 4-5. 입력 검증 + 중앙집중 예외 처리

- **엄격한 입력 검증(strict validation)**:
    
    - 잠재적으로 위험한 문자는 sanitize 또는 escape. 
        
- **에러 처리/로깅/모니터링/알림을 가능한 한 중앙집중화**:
    
    - “함수마다 제각각” 예외 처리 로직을 두지 말고
        
    - **한 곳에서 동일한 방식**으로 처리하는 정책/공통 모듈 사용.
        
- 조직 차원에서:
    
    - 이 모든 것(예외 처리 정책, 롤백 규칙, logging 규칙 등)을  
        **보안 요구사항·코딩 규칙**으로 문서화하고,  
        Threat Modeling, 코드 리뷰, 정적 분석, 스트레스/부하 테스트,  
        침투 테스트까지 묶어서 검증. 
        

---

## 5. 예시 공격 시나리오 (Example attack scenarios)

### 시나리오 1 – 예외 처리 실패로 인한 자원 고갈(DoS) 

- 파일 업로드 기능이 예외를 catch하긴 하지만,
    
    - 실패 시 **파일 핸들·메모리·DB 커넥션 등을 제대로 정리하지 않음**.
        
- 공격자가 일부러 에러를 발생시키는 업로드 요청을 반복:
    
    - 매번 예외가 나면서 리소스가 조금씩 “잠겨” 버리고,
        
    - 결국 서버 전체 리소스가 고갈 → **서비스 거부(DoS)** 상태.
        

### 시나리오 2 – DB 에러 메시지로 인한 정보 노출 & 공격 정교화 

- 애플리케이션이 DB 에러 발생 시,
    
    - 사용자에게 **전체 스택 트레이스/쿼리/경로 등이 포함된 내부 에러 메시지**를 그대로 보여줌.
        
- 공격자는
    
    - 이상한 입력을 반복해서 넣어 각종 에러를 터뜨리며,
        
    - DB 구조, 테이블명, 컬럼명, 사용하는 드라이버/프레임워크 등을 수집.
        
- 수집한 정보를 바탕으로
    
    - **더 정교한 SQL Injection / 기타 공격**을 설계할 수 있게 됨.
        

→ 여기서 취약점은 “SQLi 자체”가 아니라,  
**예외 상황을 잘못 처리해서 공격 Reconnaissance에 필요한 정보를 퍼주는 것**.

### 시나리오 3 – 금융 거래 중간 실패 → 상태 꼬임 & 사기 거래 

- 어떤 금융 시스템의 송금 로직이 다음 순서로 동작한다고 하자:
    
    1. A 계좌에서 돈 인출 (debit A)
        
    2. B 계좌에 입금 (credit B)
        
    3. 로그 기록
        
- 공격자가 네트워크를 일부러 끊거나,  
    타이밍을 맞춰 요청을 반복/중단시키면:
    
    - 1번은 성공했는데 2번/3번에서 예외 발생,
        
    - 시스템이 **전체 롤백을 제대로 안 하고 중간 상태를 유지**하는 설계일 경우,
        
        - A 계좌 돈만 빠지고 B는 못 받거나,
            
        - Race Condition으로 **B에 여러 번 입금**되는 상황도 발생 가능.
            
- 즉, 멱등성/트랜잭션 롤백/Fail Closed 설계가 부족해서  
    **예외 상황이 그대로 금전적 손실·사기로 이어지는 케이스**.
    

> “**모든 게 잘 돌아갈 때**”가 아니라 “**뭔가 꼬였을 때**” 시스템이 얼마나 안전하게 행동하느냐