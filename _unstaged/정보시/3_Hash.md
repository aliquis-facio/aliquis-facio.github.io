## 3.1. 해시 함수(Hash function)

- 정의: 임의 길이 입력 → **고정 길이 출력(다이제스트)** 로 매핑, **역상 구하기 어려움(일방향성)**, **출력 비트의 절반이 평균적으로 변화(어밸런치 효과)**, **충돌 찾기 계산상 불가능**이 목표.
- 예시/출력 길이: **MD5(128비트)**, **SHA-1(160비트)**, RIPEMD-160, Whirlpool 등.
- 처리 개요: 메시지를 **512비트 배수**가 되도록 패딩 후, **512비트 단위**로 압축 함수에 투입.

## 3.2. 생일 공격(Birthday attack)

- 아이디어: 생일 역설처럼, **충돌은 직관보다 훨씬 자주 발생**한다는 점을 이용. 간단한 확률 예시로 설명됨.
- 결론: **64비트 출력 해시는 부적절**, 안전한 해시 출력 길이는 **128비트 초과 권장**.

## 3.3. 메시지 인증 코드(MAC)

- 목적: **무결성 보호**, **발신자 확인**, (슬라이드 기준) **부인방지**까지 목표로 제시. 구현은 블록암호 모드 또는 **키드 해시(해시+키)** 사용.
- 키드 해시의 진화: 초기 제안 **H(Key‖m)**에는 약점이 지적되어, **HMAC**으로 발전(슬라이드는 대안으로 H(m‖Key) 표기).
- 활용: 파일/OS 이미지/소스 무결성 점검(Tripwire 등).

## 3.4. 일회용 비밀번호(OTP)

- 개념: 매 로그인마다 **새 비밀번호**를 쓰는 방식. **시간 동기형 토큰**, **수학적 알고리즘(해시 체인, 챌린지-응답)** 등이 있음.
- **시간 동기형**: 클라이언트·서버가 공유 키/시리얼을 바탕으로 **f(key, serial, time)** 값을 각각 계산해 일치 여부로 인증(시간은 느슨한 동기 필요).
- **해시 체인(S/Key)**: 서버는 **fⁿ(s)** 저장 → 로그인 때 클라이언트가 **fⁿ⁻¹(s)** 제시, 서버가 한 번 더 f를 적용해 검증 후 저장 값을 갱신.
- **챌린지-응답**: 서버 난수 **R** 제시 → 클라이언트가 **H(R‖s)** 제출 → 서버도 계산해 일치 시 통과.

