좋은 질문이에요 — 길이 확장 공격(length-extension attack)의 **핵심 메커니즘**을 이해하면 왜 `H(K ∥ m)`이 취약하고 `H(m ∥ K)`는 그렇지 않은지 명확해집니다. 아래에 핵심 포인트와 간단한 예시, 결론(권장 대책)을 정리할게요.

---

## 1) 길이 확장 공격(무엇을 이용하나)

많은 고전 해시(예: Merkle–Damgård 구조인 MD5, SHA-1, SHA-256 계열)는 다음 성질을 가집니다.

> **주장:** 해시 함수 내부는 블록 단위로 압축함수(compression)를 연쇄적으로 적용해서 최종 해시값(h)을 만든다.  
> 따라서 공격자는 `H(X)`와 `len(X)`를 알고 있으면, `X`의 내부 상태(=마지막 압축 함수 출력)를 시작점으로 삼아 **추가 데이터 Y를 이어 붙인** `H(X ∥ pad(X) ∥ Y)`를 계산할 수 있다.  
> 즉, `H(X)`로부터 `H(X ∥ pad(X) ∥ Y)`를 **알 수 있게 된다**(X의 내용을 몰라도).

이게 바로 길이 확장 공격의 핵심 메커니즘입니다.

---

## 2) 왜 `H(K ∥ m)`은 취약한가

- MAC이 `tag = H(K ∥ m)` 형태일 때, 공격자는 `m`(공개)과 `tag = H(K ∥ m)`(관찰 가능)을 갖고 있다고 가정합니다.
    
- Merkle–Damgård 성질 때문에 공격자는 내부 상태(=tag)를 초기 상태로 삼아 임의의 `Y`를 추가하여 `H(K ∥ m ∥ pad(K ∥ m) ∥ Y)`를 계산할 수 있습니다.
    
- 그러면 공격자는 메시지 `m' = m ∥ pad(K ∥ m) ∥ Y`에 대한 유효한 태그(=`H(K ∥ m' )`)를 만들어 낼 수 있다 — **키 K를 모른 채로**.
    
- 서버가 `m'`에 대해 `H(K ∥ m')`를 계산해 검증하면 공격자가 만든 값과 일치하므로 위조가 성공합니다.
    
- 결론: **비밀을 앞(prefix)으로 붙이는 형태 `H(K ∥ m)`은 길이 확장 공격으로 메시지 위조가 가능**하다.
    

> 실무적으로 WEP 같은 약한 프로토콜에서 이 취약성이 악용된 사례가 있습니다.

---

## 3) 왜 `H(m ∥ K)`는 (같은 길이 확장 기법에 대해) 덜 취약한가

- 공격자가 `tag = H(m ∥ K)`를 얻었다고 해도, 길이 확장은 `H(m ∥ K ∥ pad(m ∥ K) ∥ Y)`를 만들어 줍니다. 이 값은 `m'`(공격자가 만들고자 하는 새로운 메시지)와 대응되는 `H(m' ∥ K)`와는 **다릅니다**.
    
- 즉, 공격자가 얻을 수 있는 것은 “원래 입력(=m ∥ K)에 _그 뒤에_ 무언가를 붙인 해시”이지, “m에 무언가를 붙이고 그 뒤에 K가 오는 형태”가 아닙니다.
    
- MAC으로서의 위조 목표는 보통 `H(m' ∥ K)` (즉 공격자가 서버에 제출할 새로운 m'의 태그) 이므로, 길이 확장으로 얻을 수 있는 값은 그 요구형태와 맞지 않아 바로 위조에 쓰기 어렵습니다.
    
- 추가로 공격자가 `H(m ∥ K)`로부터 시작해 `H(m ∥ K ∥ pad ∥ Y)`를 만드는 데는 원래 입력의 전체 길이(특히 K의 길이)를 알아야 하는데, K 길이를 모르면 시도는 더 복잡해집니다(길이 추측으로 시도는 가능하지만 실용적이지 않음).
    

따라서 **단순 길이 확장 기법**은 `H(m ∥ K)` 형태의 MAC을 손쉽게 깨지는 못합니다.

---

## 4) 그렇다고 `H(m ∥ K)`가 안전하냐?

- **아니오.** `H(m ∥ K)`가 길이 확장 공격에는 덜 취약하지만, MAC으로 안전하다고 보장되지는 않습니다.
    
- 예를 들어 동일한 해시 함수를 사용한 충돌 공격, 또는 키 길이 유출에 따른 다른 공격 벡터, 직렬화 문제 등 여전히 위험이 있습니다.
    
- 그래서 실무에서는 다음처럼 **검증된 방식(HMAC 등)**을 사용합니다.
    

---

## 5) 실무 권장 — HMAC

- HMAC은 내부적으로 키를 블록 크기에 맞게 패딩하고 **내부 해시(inner)와 외부 해시(outer)** 두 번 적용해 Merkle–Damgård 길이 확장 취약성을 피합니다:
    
    ```
    HMAC_K(m) = H( (K' ⊕ opad) ∥ H( (K' ⊕ ipad) ∥ m ) )
    ```
    
- HMAC은 Merkle–Damgård 기반 해시(SHA-256 등)에서 **길이 확장 공격에 안전**하도록 설계된 표준 방식입니다.
    

또한 SHA-3(Keccak)처럼 Merkle–Damgård가 아닌 해시 설계는 길이 확장 취약성이 다르게 작동하거나 적용되지 않습니다. 하지만 호환성과 검증된 보안성을 위해 HMAC 사용이 일반 권장입니다.

---

## 6) 요약

- Merkle–Damgård 구조의 해시에서는 `H(X)`로부터 `H(X ∥ pad(X) ∥ Y)`를 계산할 수 있음 → **길이 확장 공격**.
    
- **`H(K ∥ m)`** (키를 앞에 둔 경우)는 이 성질 때문에 **위조에 취약**(공격자가 `m`을 확장하여 유효한 태그 생성 가능).
    
- **`H(m ∥ K)`** (키를 뒤에 둔 경우)는 길이 확장으로 공격자가 원하는 형태인 `H(m' ∥ K)`를 직접 만들기 어렵기 때문에 같은 방식으로는 약해 보이지만, 여전히 MAC으로 안전하다고 보장할 수는 없음.
    
- **권장:** 직접 `H(K||m)` 또는 `H(m||K)` 같은 단순 구성 사용 금지 — 대신 **HMAC** 또는 AEAD/표준 MAC 사용.
    

원하시면 `간단한 예제(파이썬)`로 길이 확장 공격이 어떻게 작동하는지 시뮬레이션해 보여드릴게요 — 어떤 해시(SHA-1/SHA-256 등)로 볼까요?