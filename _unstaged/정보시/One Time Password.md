# One Time Password, OTP

- 암호화 알고리즘과 Key(Seed)는 고정이고, 평문에 따라 암호문을 생성하는 암호 체계이다.
- 인증(신원 확인). 사용자와 서버가 공유한 비밀과 시간/카운터로 코드 생성 → 재사용/재전송 공격에 강함

## S/KEY(= Lamport 해시 체인) 방식

- **S/KEY(= Lamport 해시 체인) 방식의 OTP**는 비밀 값(패스프레이즈/씨드에서 파생된 값)을 **서버에 알려주거나 서버가 보관할 필요가 없습니다.**
- 초기 등록: 클라이언트가 ($V_n = H^{n}(\text{secret} \parallel \text{seed})$) 같은 **체인의 머리값**만 서버에 등록합니다(비밀 자체는 미전송).
- 로그인 (i)번째: 클라이언트가 ($V_{i-1}$)을 보내면, 서버는 한 번 더 해시해서 ($H(V_{i-1}) \stackrel{?}{=} V_i$)를 확인하고, 성공하면 저장값을 ($V_{i-1}$)로 갱신합니다.
- 따라서 서버는 **해시값만** 갖고 검증하며, **비밀(secret)** 은 끝까지 서버에 알려지지 않습니다.

보안상 유의점
- 도청자는 OTP를 재사용할 수 없지만, **실시간 피싱/MITM**엔 취약할 수 있습니다.
- 서버의 저장값(해드/씨드)이 유출되면 **사전 대입 공격** 가능성이 있으니 비밀은 충분히 강하게(긴 패스프레이즈 등) 해야 합니다.

※ 비교: **HOTP/TOTP**는 서버가 **공유 비밀키**를 저장해야 하지만, **S/KEY는 비밀을 서버가 몰라도** 해시 체인으로 검증이 가능합니다.

## Time-based OTP

**TOTP**: 서버·클라이언트가 같은 시계와 비밀키를 공유하고  
`OTP = Truncate(HMAC(K, ⌊(now−T0)/X⌋))` 처럼 **시간 슬롯**을 입력으로 사용합니다.  
→ 서버가 별도의 챌린지를 보내지 않습니다(시간은 예측 가능).

## Challenge-Response 방식

서버에서 난수 생성 등을 통해 임의의 수를 생성하고 클라이언트에 그 값을 전송하면, 클라이언트가 그 값으로 OTP를 생성해 응답한 값으로 인증하는 방식이다.  
입력값이 매번 임의의 값이 된다는 측면에서는 안전성을 갖추고 있으나, 네트워크 모니터링에 의해 전송되는 값들이 노출될 경우 매우 취약해진다는 단점이 있다. 또 서버와 클라이언트 사이의 통신 횟수도 비교적 많이 요구된다.