# 소프트웨어 공학 개요 정리
## 1. 소프트웨어 위기(SW Crisis)

- “소프트웨어는 절대 결함이 0이 될 수 없다.”
- “결함은 운영 중에 드러나며, 사전 품질 확보가 핵심.”
- “큰 프로젝트는 수백 개의 디펙트가 한 번에 터진다.”

### 1.1. 등장 배경

- 1968년 NATO에서 처음 제기된 문제
- 컴퓨터 성능 폭증 → 문제 복잡도 증가 → 기존 방식으로 개발 불가능

### 1.2. 주요 원인

- 소프트웨어 규모 대형화 → 비용 급증
- 유지보수 어려움
- 일정·예산 예측 어려움
- 요구사항 변경 빈번
- 개발자 전문성 불균형

### 1.3. 실제 사례

- **Jeep 체로키 원격 해킹 사고** 무선 접속으로 차량 정지 유도
- **Tesla 자율주행 사고** 흰색 트럭과 하늘을 구분 못함
- **Toyota 급발진** 연료 제어 SW 결함
- → 현실 세계에서 SW 결함은 **안전·생명 문제**로 확장됨.

## 2. 소프트웨어 개발이 어려운 이유

- 의사소통 문제
	- 다양한 역할자(기획–개발–QA–운영–고객) 간 관점 차이
	- 교수: “현업에서 제일 중요한 역량 = 의사소통”
- 시스템 순차성
	- 3차원 현실을 2차원 코드로 구현하는 본질적 한계
- 개발 결과물의 특성
	- 물리 제품이 아닌 **지적 산출물**
	- 개발자마다 품질 편차 큼
- 프로젝트 복잡성
	- 기간, 인력, 기술 스택, 외주 구조 등 모든 요소가 매번 다름
	- 협력업체 다수 참여 시 책임소재 불명확
- 관리 이슈
	- 버전관리, 일정관리, 요구사항관리 등
	- 오케스트레이션 필요

## 3. 인공지능 시대의 새로운 소프트웨어 위기

- “AI가 잘하는 분야에선 잘하지만, 다른 영역에선 품질이 급격히 떨어질 수 있다.”
- “AI 시스템도 결국 소프트웨어이므로 품질 기준이 필요하다.”

### 3.1. AI 기반 SW의 특징

- 모델 출력이 **불확실**, **시간에 따라 변화**
- 캡슐화·모듈화 같은 기존 SW 원칙 적용 어려움
- 데이터 품질이 전체 품질을 결정
- 공정성·투명성·편향성 이슈

### 3.2. 품질 관점 5요소

- **투명성/책임성**
- **공정성·다양성**
- **보안·안전성**
- **견고성/신뢰성**
- **법·윤리성**

## 4. 소프트웨어 공학적 기법의 발전
- 구조적 프로그래밍 (1970s)
	- Fortran, COBOL, C
	- 자료흐름도, 구조 차트 기반 설계
	- 장점: 단순·체계적
	- 단점: 시스템이 커지면 유지보수 어려워짐
- 객체지향 프로그래밍 (1980s)
	- class, 상속, 다형성
	- UML 기반 분석/설계
	- 실세계 모델링에 적합
	- 교수: “현대 대부분의 시스템이 객체지향 기반”
- 컴포넌트 기반 개발 (1990s)
	- 재사용성 극대화
	- OSS 재사용 증가
	- Unity/Framework 등 엔진 기반 개발도 동일 철학
- 현대 개발 환경
	- IDE
	- 개발 프로세스 (Waterfall, Agile, DevOps)
	- 테스트 & 검증
	- 형상관리 (Git, ClearCase 등)
	- “대기업은 형상관리 담당자와 통합 빌더가 따로 존재”

## 5. 소프트웨어 공학의 원리

- 엄격성과 정형성
	- 시간·비용·품질 제약 내에서 정확히 개발 필요
- 관심사의 분할
	- 요구분석 → 설계 → 구현 → 테스트
	- 단위/통합/시스템 테스트 분리
- 모듈화
	- 높은 응집도
	- 낮은 결합도
	- 변경 영향 최소화
- 추상화
	- 본질만 남기고 복잡도 제거
	- 예: 함수, 클래스, 인터페이스
- 변경의 예측
	- 변경 가능성이 높은 영역을 따로 모듈화해둔다.
- 일반화
	- 다양한 환경에서 동작 가능하도록 설계
- 점진성
	- 작은 단위를 단계적, 반복적으로
	- Agile·Iterative 방식과 연결
- 명세화
	- 문서화, 공유, 추적 가능성 제공
	- “회사에서 진짜 필요한 건 코드 + 문서 + 기록”

## 6. 소프트웨어 품질(Quality)

- “초기엔 멀쩡해 보여도 내부 품질이 낮으면 운영 중에 지옥이 열린다.”
- “좋은 SW는 운영팀의 삶을 편하게 해준다.”

### 6.1. 품질의 특징

- 눈에 안 보임(비가시성)
- 요구사항이 처음부터 완전하지 않음
- 시간이 지날수록 기준이 올라감
- 기술 발전 속도가 빠름
- 절대평가 불가능(100점 없음)
- 다양한 이해관계자가 존재

### 6.2. 품질 정의

- **사용 목적에 맞는 적합성**
- **명세된 요구사항을 충족시키는 정도**
- **고객·사용자 만족도**

### 6.3. 품질이 중요한 이유

- 시장 신뢰도 향상
- 유지보수 비용 절감
- 기업 수익 증가

### 6.4. 품질의 아이스버그(보이는 vs 보이지 않는 품질)

- 외적 품질: 신뢰성, 효율성, 비용
- 내적 품질: 결합도, 재사용성, 코드 규칙, 복잡도 등
- 운영 후 결함이 터지는 대부분은 **내적 품질 미흡 때문**

## 7. 품질 모델
### 7.1. ISO 9126

6대 품질 특성:
1. 기능성
2. 신뢰성
3. 사용성
4. 효율성
5. 유지보수성
6. 이식성

### 7.2. ISO 25010

8대 특성:
1. 기능적 적합성
2. 성능 효율성
3. 호환성
4. 사용성
5. 신뢰성
6. 보안성
7. 유지보수성
8. 이식성

→ **현대 기준의 대표 품질 모델**

## 8. 프로세스 품질

좋은 품질의 SW는 좋은 프로세스에서 나온다.

### 8.1. 핵심 요소

- **적합한 프로세스 모델 선택**
- 객체지향/구조적/정보공학 방법론 선택
- CASE Tools 적합성
- 표준 준수 여부 (코딩 표준 등)
- 프로젝트 데이터의 기록/재사용성

## 9. 개발 방법론

- “Agile의 핵심은 빠른 피드백”
- “요즘 학생들은 해커톤 형태가 Agile과 유사한 경험”
- “TDD는 시간이 들지만 품질을 압도적으로 높인다”

### 9.1. Waterfall

- 장점: 명확한 문서, 예측 가능
- 단점: 요구 변경 대응 어려움
- 교수 실무 경험: “요구사항 오해로 지옥 경험”

### 9.2. Agile (XP 포함)

- 빠른 피드백
- 사용자 중심
- 단기 반복
- Pair Programming, TDD 등 적용 가능

## 10. 시큐어 코딩

- 최근 기업들은 보안 요구사항에 **Secure Coding 준수** 요구
- 취약점 유형 파악 필요
- 방어적 프로그래밍
- C/C++ 계열은 메모리 취약점 중심
- Python/JavaScript도 입력 검증 중요

→ **SW 품질 = 기능 품질 + 보안 품질**