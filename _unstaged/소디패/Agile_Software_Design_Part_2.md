## Part 2. 애자일 설계

**기민성(agility)**: 아주 조금씩 소프트웨어를 만들어나가는 것

**객체 지향 설계 원칙**
* SRP(Single Responsibility Principle): 단일 책임 원칙
* OCP(Open-Closed Principle): 개방 폐쇄 원칙
* LSP(Liskov Substitution Principle): 리스코프 치환 원칙
* DIP(Dependency Inversion Principle): 의존 관계 역전 원칙
* ISP(Interface Segregation Principle): 인터페이스 분리 원칙

설계의 악취는 대개 하나 이상의 원칙을 위반했을 때 발생.
아무 악취도 나지 않을 때는 원칙을 적용하지 않음. 그저 원칙이라는 이유만으로 무조건 따르는 것은 좋지 않음.

### Chapter 7. 애자일 설계란 무엇인가?

UML 다이어그램 ⊂ 설계
소프트웨어 프로젝트의 설계는 추상적인 개념 → 구체적인 각 모듈, 클래스, 메소드의 형태와 구조뿐만 아니라 프로그램의 전체 형태와 구조와도 관련됨. 최종 구현은 소스 코드.

#### 1. 애자일 설계의 의미

- 소프트웨어 설계는 처음부터 완벽하게 하는 것이 아니라 **작은 단위의 반복적인 개발** 속에서 **점진적으로 진화**하는 것.
- 설계의 목표는 **유연성, 유지보수성, 재사용성**을 확보하는 것.
- 미래의 요구를 과도하게 예측하는 대신, **현재의 필요에 집중**하여 설계를 단순화하고 필요할 때 개선(refine)한다.

#### 2. 나쁜 설계의 징후 (Symptoms of Poor Design)

애자일 설계가 강조되는 이유는, 잘못된 설계가 아래와 같은 문제를 일으키기 때문이다:
1. **경직성(Rigidity)** – 작은 변화에도 전체 시스템을 크게 수정해야 함.
	- 의존적인 모듈에서 단계적으로 계속 변경을 일으킴
2. **취약성(Fragility)** – 한 부분을 수정하면 다른 부분이 쉽게 깨짐.
	- 변경한 영역과 아무런 관계가 없는 영역에서 문제가 발생함
3. **비재사용성(Immobility)** – 다른 프로젝트나 맥락에서 재사용하기 어려움.
	1. 부동성: 다른 시스템에서 유용하게 쓸 수 있는 부분을 포함하고 있지만, 그런 부분을 원래 시스템에서 분리하는 수고와 위험성이 지나치게 클 때 설계는 움직이게 할 수 없다.
4. **점착성(Viscosity)** – 좋은 방법보다 잘못된 방법을 쓰는 것이 더 쉬운 상황.
	- 소프트웨어의 점착성: 변경사항을 마주했을 때, 개발자는 보통 그 변경을 수행하는 한 가지 이상의 방법을 찾는다. 그중 일부는 설계를 유지하는 방법이고, 나머지는 그렇지 않다. 설계 유지 방법이 엉터리 방법보다 사용하기 어렵다면, 설계의 점착성을 높아진다. 이 경우 잘못된 동작을 하기는 쉽지만, 옳은 동작을 하기는 어렵다. 프로그래머는 설계를 유지할 수 있도록 변경이 쉬운 소프트웨어를 설계하고 싶어 한다.
	- 환경의 점착성: 개발 환경이 느리고 비효율적일 때 발생
5. **불필요한 복잡성(Needless Complexity)** – 실제 필요 없는 구조나 기능을 미리 설계해 과도하게 복잡해짐.
6. **불필요한 반복(Needless Repetition)** – 코드 중복.
7. **불투명성(Opacity)** – 코드가 복잡하고 읽기 어려워 의도를 이해하기 힘듦.

#### 무엇이 소프트웨어의 부패를 촉진하는가?

애자일이 아닌 환경에서는, 초기 설계에서 예상하지 않았던 요구사항 변경 때문에 설계가 퇴화하게 된다. 대개 이런 변경은 빠르게 이루어져야 하고, 이 일은 원래의 설계 철학에 익숙하지 않은 개발자들이 맡게 된다.
하지만 설계 퇴화 문제에 있어 요구사항의 표류를 탓할 수는 없다.

#### ‘Copy’ 프로그램

대부분의 소프트웨어 프로젝트에서 가장 변덕스러운 요소는 바로 요구사항이다.
우리는 변하는 요구사항의 세계에 살고 있고, 우리가 만든 소프트웨어가 이런 변화 속에서 살아남을 수 있게 만드는 것이 바로 우리가 해야 하는 일이다.

STRATEGY 패턴

#### 애자일 개발자는 해야 할 일을 어떻게 알았는가?

의존성의 방향, 직접 의존 → 하위 수준의 세부 사항이 바뀔 때, 상위 수준의 정책이 영향을 받게 됨.
1. 그들은 애자일 실천 방법을 다라 하며 문제를 찾아냈다.
2. 그들은 설계 원칙을 적용해 문제를 진단했다.
3. 그리고 적절한 디자인 패턴을 적용해 문제를 해결했다.

#### 가능한 한 좋은 상태로 설계 유지하기

설계를 가능한 한 적절하고 명료한 상태로 유지하기 위해 애쓴다
애자일 개발자는 매일, 매시간, 심지어 분마다 소프트웨어를 가능한 한 명료하고, 간단하고, 표현적인 상태로 유지한다.
설계는 명료한 상태로 유지되어야 한다. 그리고 설계의 가장 중요한 표현인 소스 코드 역시 명료한 상태로 유지되어야 한다.

#### 3. 객체지향 설계의 핵심 원칙 (Preview)

애자일 설계는 이러한 문제를 해결하기 위해 **객체지향 설계 원칙**(SOLID 등)을 적용한다.
- SRP (단일 책임 원칙)
- OCP (개방-폐쇄 원칙)
- LSP (리스코프 치환 원칙)
- DIP (의존 역전 원칙)
- ISP (인터페이스 분리 원칙)
이 원칙들은 “설계의 냄새(smell)”를 줄이고, 소프트웨어의 구조를 단순하고 명확하게 유지하는 데 도움을 준다.

#### 4. 요약

- **설계는 정적 산물이 아니라 동적인 과정**이다.
	- 애자일 설계는 과정이지, 결과가 아니다. 이것은 원칙, 패턴, 그리고 소프트웨어의 구조와 가독성을 향상하기 위한 방식의 연속적인 적용이다. 모든 시점에서 시스템의 설계를 가능한 한 간단하고, 명료하고, 표현적으로 유지하려는 노력이다.
	- 원칙과 패턴은 매 주기를 거치면서 코드 및 코드가 포함하는 설계를 명료하게 유지하려는 시도의 일환으로 적용된다.
- **좋은 설계란 미래를 완벽히 예측하는 것이 아니라, 변화에 쉽게 적응할 수 있도록 단순하고 유연하게 유지하는 것**이다.
- 따라서 애자일 설계는 “필요할 때, 필요에 맞게, 지속적으로 개선하는 설계”이다.

---

### Chapter 8. 단일 책임 원칙

**응집도(cohesion)**: 모듈 요소 간의 기능적인 연관
→ 모듈이나 클래스의 변경을 야기하는 응집력

#### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

- **정의:**  한 클래스는 **오직 하나의 변경 이유(reason to change)** 만 가져야 한다.
- 즉, 클래스는 단 하나의 책임(Responsibility)만 가져야 하며, 그 책임을 수행하는 데 집중해야 한다.

#### 2. 왜 중요한가?

- 여러 책임을 가진 클래스는 **변경에 취약**하다.
    - 각 책임이 변경의 축임 → 요구사항이 변경될 때, 이 변경은 클래스 안에서의 책임 변경을 통해 명백해짐.
    - 한 기능을 수정했을 때, 관련 없는 기능까지 영향을 받을 수 있음.
    - 이로 인해 코드 유지보수가 어려워지고, 의도치 않은 버그가 발생.
- **응집도(cohesion)** 가 높은 클래스는 설계가 단순하고, 변경 범위가 명확하다.

#### 3. 예시

- **잘못된 사례:**  `Rectangle` 클래스가 **기하학적 계산**(넓이, 둘레 등)과 **화면 출력**(그리기)을 동시에 책임진다면, 출력 로직이 바뀔 때 기하학적 코드까지 수정해야 한다.
	- ![](20250924165209.png)
- **개선된 설계:**  `Rectangle`은 기하학적 계산만 담당하고, 출력은 `RectanglePrinter` 같은 별도 클래스가 담당해야 한다.
	- ![](20250924165403.png)

#### 책임이란 무엇인가?

책임(responsibility): SRP의 맥락에서, 변경을 위한 이유로 정의됨
→ 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것임.

애플리케이션이 어떻게 바뀌느냐에 따라 책임을 분리하느냐 마냐가 달려있음.
→ 애플리케이션이 서로 다른 시간에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면, 분리할 필요가 없음. 오히려 분리할 경우, 불필요한 복잡성이 발생함.
변경의 축은 변경이 실제로 일어날 때만 변경의 축임.

#### 결합된 책임 분리하기

바람직한 일은 아니지만 모든 의존성은 필요악일 수 있다. 하드웨어나 OS의 세부적인 사항과 관련된 이유로 인해, 오히려 책임이 결합되도록 만드는 경우가 종종 있다. 하지만 인터페이스는 분리하여 애플리케이션의 나머지 부분에 한해 개념을 분리했다.

#### 4. SRP 위반의 결과

- **변경 비용 증가:** 작은 변경이 여러 부분의 코드를 수정하게 만듦.
- **재사용성 저하:** 클래스가 불필요하게 많은 책임을 가지면 재사용하기 어려워짐.
- **이해도 하락:** 클래스가 커지고 복잡해져 의도를 파악하기 어려워짐.

#### 5. SRP 준수의 효과

- **변경 용이성 증가:** 책임이 분리되므로 특정 기능 변경 시 해당 클래스만 수정하면 됨.
- **재사용성 향상:** 잘 정의된 책임을 가진 클래스는 다른 맥락에서도 활용하기 쉬움.
- **코드 가독성 향상:** 클래스의 역할이 명확해져 코드 이해가 쉬워짐.

#### 6. 핵심 교훈

- 클래스 설계 시, **“이 클래스가 변경될 이유가 몇 개인가?”** 를 스스로 물어봐야 한다.
- 두 개 이상의 변경 이유가 있다면 SRP 위반 가능성이 높으므로 책임을 분리해야 한다.

---

### Chapter 9. 개방 폐쇄 원칙

> 모든 시스템은 생명주기 동안에 변화한다. 이것은 개발 중인 시스템이 첫 번째 버전보다 오래 남길 원한다면 반드시 염두에 두어야 할 사실이다.
> *Ivar Jacobson*

#### 1. 개방-폐쇄 원칙 (OCP, Open–Closed Principle)

- **정의:**  소프트웨어 엔티티(클래스, 모듈, 함수 등)는 **확장에는 열려(Open for extension)** 있으면서, **수정에는 닫혀(Closed for modification)** 있어야 한다.
- 즉, 새로운 기능을 추가할 때 기존 코드를 수정X, 새로운 코드 추가를 통해 확장할 수 있어야 한다.

#### 상세 설명

두 가지 주요 속성
1. 확장에 대해 열려 있다: 모듈의 행위가 확장될 수 있다. 애플리케이션의 요구사항이 변경될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
2. 수정에 대해 닫혀 있다: 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

#### 2. 왜 중요한가?

- 변화는 불가피하다. → 요구사항이 바뀔 때마다 기존 코드를 고친다면 시스템은 **취약하고 불안정**해짐.
- OCP를 따르면 기존 코드를 건드리지 않고 새로운 기능을 추가하므로 **안정성과 재사용성**이 높아진다.

#### 3. OCP 달성 방법

추상화는 추상 기반 클래스이자, 모든 가능한 파생 클래스를 대표하는 가능한 행위의 제한되지 않은 묶음이다.

모듈은 추상화를 조작할 수 있다. 이런 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다. 그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

추상 클래스는 자신을 구현하는 클래스보다도 클라이언트에 더 밀접하게 관련되어 있다.

- **추상화(Abstraction)와 다형성(Polymorphism) 활용**
    - 공통 인터페이스(또는 추상 클래스)를 정의하고,
    - 새로운 기능은 인터페이스를 구현한 새로운 클래스 추가로 해결.
- **예시:**
    - 도형(Shape) 클래스 계층:
        - 추상 클래스 `Shape` → `draw()` 메서드 정의.
        - 새로운 도형(예: Circle, Square, Triangle)은 `Shape`를 상속받아 `draw()` 구현.
        - 이렇게 하면 새로운 도형 추가 시 기존 코드를 수정할 필요 없음.
![](20250924171853.png)
![](20250924171914.png)

#### 4. OCP 위반 사례

- 새로운 기능을 추가할 때마다 `if-else`나 `switch-case`문을 수정해야 하는 경우.
- 예: `drawShape(Shape s)` 함수 안에서 Circle, Square를 `if`로 구분해 처리. → 새로운 도형을 추가하면 함수를 매번 수정해야 함.

#### 예상과 ‘자연스러운’ 구조

일반적으로, 모듈이 얼마다 ‘닫혀’ 있든지 간에, 닫혀 있지 않은 것에 대한 변경은 항상 존재한다. 모든 상황에서 자연스러운 모델은 없다.
폐쇄는 완벽할 수 없기 때문에, 전략적이어야 한다. 즉, 설계자는 자신의 설계에서 닫혀 있는 변경의 종류를 선택해야 한다.
어떤 변경이 있을 법한지 어떻게 알 수 있을까? 적절한 연구를 하고, 적절한 질문을 던지고, 경험과 상식을 이용해야 한다. 그리고 그 모든 것을 한 후에, 변경이 일어날 때까지 기다린다.

#### ‘올가미’ 놓기

지나치고 불필요한 추상화로 설계에 부하를 주지 않으려면, 추상화가 필요할 때까지 기다렸다가 올가미를 놓는 편이 차라리 낫다.

처음에는 코드가 변경되지 않을 것이라 생각하고 작성한다.
첫 번째 총알은 그냥 맞고, 그 총에서 쏘는 다른 총알에 대해서는 확실히 보호한다.

##### 변경 촉진하기

* 테스트를 먼저 작성한다. 테스트를 먼저 작성함으로써, 시스템을 테스트 가능한 것으로 만들 수 있다.
* 아주 짧은 주기로(주보다는 일 단위로) 개발한다.
* 기반구조보다 기능 요소를 먼저 개발하고, 자주 이 기능 요소를 이해당사자에게 보여준다.
* 가장 중요한 기능 요소를 먼저 개발한다.
* 소프트웨어를 빨리, 그리고 자주 릴리즈한다.

#### 명시적인 폐쇄를 위해 추상화 사용하기

폐쇄는 추상화에 기반을 둔다
순서에 대해 닫으려면, 순서 추상화를 만들어라

#### 5. 한계

- 모든 변경을 100% 막을 수는 없다.
- 예를 들어, 시스템의 **기본 아키텍처 자체가 바뀌는 경우**는 기존 코드를 수정할 수밖에 없다.
- 따라서 OCP는 절대적인 규칙이 아니라 **변화가 예상되는 지점에 적용하는 설계 지침**이다.

#### 6. 효과

- 변경 요구가 생겨도 기존 코드는 안정적으로 유지됨.
- 새로운 기능 추가가 용이 → 확장성 증가.
- 기존 코드와 신규 기능의 결합도가 낮아져 **유지보수성** 향상.