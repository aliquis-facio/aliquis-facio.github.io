교수님이 “시험에 나온다”고 말한/강조한 내용만 정리해서 싹 다 적을게요. 

---

## 1. 시험 형식 & 범위 비중

* **형식**
	  * **전부 주관식** (객관식 없음)
	  * **문제 수 약 15문제**, 총 **30점**. 문제 옆에 배점 표시.
	  * **키워드 쓰기 / 키워드 설명 / 비교 / 장단점 서술** 형태.
	  * **단답형 키워드**는 **정확한 용어, 철자 틀리면 오답** 처리.

* **비중(대략 6:4)**
	  * **소프트웨어 디자인 패턴 쪽이 약 60% (반 이상)** – 이 과목의 핵심.
	  * 나머지 **애자일/개발 방법론/TDD/XP/DevOps/소프트웨어 품질·시큐어 코딩·SOLID** 등 약 40%.

---

## 2. 앞부분 과제 연계: 품질, 객체지향, SOLID, 의존성 관리

교수님이 “**과제 내용만 충실히 잘 보면 된다**”고 한 구간입니다.

1. **소프트웨어 품질을 높이는 여러 가지 방식**
	* 수업/과제에서 찾았던 **품질 향상 방법들** 정리.
	* **품질 특성(기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 등)** 개념적인 이해. (표준 번호 외우는 건 X)
2. **소프트웨어 품질 개념 & 품질 특성**
	* <font color="#ff0000"> **“소프트웨어 품질이 왜 중요한지?”** 설명할 수 있어야 함.</font>
	* ISO/IEC 같은 **품질 표준이 존재한다는 정도** + “품질을 측정하기 위해 사용된다” 정도만.
3. **객체지향 개념(OO 개념)**
	* 객체, 클래스, 캡슐화, 상속, 다형성 등 **기본 OOP 개념**.
4. **의존성 관리(Dependency Management)**
	* 객체 간 의존성을 줄이고, 느슨한 결합을 지향하는 설계 개념.
5. <font color="#ff0000">**객체지향 설계 5대 원칙 – SOLID**</font>
	* <font color="#ff0000">**SRP**: Single Responsibility Principle – **하나의 객체는 하나의 역할만**</font>
	* <font color="#ff0000">**OCP**: Open/Closed Principle</font>
	* <font color="#ff0000">**LSP**: Liskov Substitution Principle</font>
	* <font color="#ff0000">**ISP**: Interface Segregation Principle</font>
	* <font color="#ff0000">**DIP**: Dependency Inversion Principle</font>
	 → **약어와 풀네임, 각각이 말하는 핵심 의미**를 설명할 수 있어야 함.

---

## 3. 9주차: 소프트웨어 품질 & 코드 품질, 리팩토링, 코딩 표준

1. **소프트웨어 품질(품질 특성)**

   * 앞에서 말한 **품질이 왜 중요한지, 어떤 특성들로 품질을 본다** 정도.

2. **코드 퀄리티 & 리팩토링 개념**

   * **Refactoring**:

     * 정의: 외부 동작은 유지하면서 코드 구조를 개선하는 것.
     * 왜 하는지: **가독성 향상, 유지보수성 향상, 버그 감소, 확장 용이성** 등.
   * **“리팩토링을 왜 하는지, 목적”**을 말할 수 있어야 함.

3. **코딩 표준 / 코딩 컨벤션**

   * 조직/팀마다 정한 **코딩 스타일, 네이밍 규칙, 포맷팅 규칙** 등.
   * 코드 퀄리티와 시큐어 코딩과도 연결.

4. **오픈소스 라이선스**

   * **라이선스 정책이 존재한다** 정도.
   * 이 부분은 **상세히는 스킵 가능하다고 언급** – 시험 비중은 낮음.

---

## 4. 10주차: 개발 프로세스, 애자일, 스크럼/칸반

### 4-1. 전통적 개발 프로세스 vs 애자일

1. **전통적 방식 모델**

   * 교수님이 언급한 **대표 모델 2개 차이**:

     * (녹음상 표현) **“폭포수 모델과 … 프로세스 차이”** – 요지는 **전통적 순차 모델 vs 반복/프로토타입/애자일** 비교.
   * 시험 포인트:

     * **전통적 프로세스의 특징**: 단계가 고정, 상향식 문서화, 요구사항 변경에 취약 등.
     * **애자일과의 차이, 장단점 비교**.

2. **프로토타입(Prototype)**

   * **빠르게 동작하는 모형을 만들어 요구사항/아이디어를 검증하는 방법**.

3. **애자일(Agile)의 특징**

   * **짧은 반복, 고객과의 지속적인 피드백, 변화 수용, 작동하는 소프트웨어 중시** 등.
   * 시험에서 **애자일의 특징을 서술**하거나, 전통 방법과 비교할 수 있음.

### 4-2. 애자일 용어: Scrum, Sprint, Kanban

1. **Scrum**

   * 역할: **Scrum Master** 등.
   * **Sprint** 단위로 개발, 정기적인 회고/데일리 스크럼 등.

2. **Sprint**

   * 정해진 기간 동안 수행하는 **짧은 개발 주기**.

3. **Kanban(칸반)**

   * **작업 흐름을 시각화**(보드, 카드), WIP 제한 등.

4. **애자일 vs Waterfall 비교**

   * 차이점, 장단점을 **표나 문장으로 비교해서 쓸 수 있어야** 한다고 강조.

---

## 5. 11주차: TDD (Test-Driven Development)

1. **TDD 기본 개념**

   * **테스트를 먼저 작성한 뒤, 그 테스트를 통과시키는 최소한의 코드를 작성하고, 리팩토링하는 개발 방식**.
   * “TDD란 무엇인가?”에 서술형으로 답할 수 있어야 함.

2. **Red–Green–Refactor 단계**

   * **Red**: 실패하는 테스트 작성.
   * **Green**: 테스트를 통과시키는 최소 구현.
   * **Refactor**: 중복 제거, 구조 개선.
   * **각 단계가 의미하는 바**를 설명할 수 있어야 함.

3. **TDD 절차 / 단계**

   * 테스트 작성 → 코드 작성 → 리팩토링의 반복.
   * **절차 개념, 장점, 단점**을 물어볼 수 있다고 언급.

4. **Mock(목 객체), 외부 의존성 최소화**

   * **목 객체(Mock Object)**: 외부 시스템/의존성을 가짜로 대체해 테스트를 쉽게 하고, 외부에 덜 의존하도록 하는 기법.
   * “**외부 의존성을 최소화한다**”는 TDD의 중요 개념.

5. **장점/단점**

   * 장점: 설계 품질 향상, 리팩토링 용이, 버그 감소 등.
   * 단점: 초기 비용/시간 증가, 테스트 작성이 어렵다 등.
   * **각 단계의 특징, 장단점, 단계 간 차이**를 물어볼 수 있다고 직접 말함.

※ 구현 코드 직접 쓰는 문제는 **안 나옴** – 절차/개념/장단점 위주.

---

## 6. 12주차: XP & DevOps

1. **XP(eXtreme Programming)**

   * XP가 주장하는 **여러 실천 방법(Practice)**들 (TDD, Pair Programming, Continuous Integration 등).
   * **XP의 전체적 개념**을 설명할 수 있어야 함.

2. **DevOps(데브옵스)**

   * Dev + Ops의 결합, **개발과 운영을 통합하여 빠르고 안정적인 배포**를 지향.
   * **DevOps의 개념, 프로세스, 장단점** 이해.
   * **CI/CD**:

     * Continuous Integration / Continuous Delivery(or Deployment)
     * 자동 빌드, 테스트, 배포 파이프라인.
   * **운영/유지보수, 배포 전략, 지속적 관리의 중요성**.

3. **CMMI, Six Sigma 같은 품질/프로세스 성숙도 모델**

   * 이름 정도, “과정/품질을 측정·개선하기 위한 모델” 정도만 알면 되고,
   * **세부 내용은 외우지 않아도 된다**고 언급.

4. **DevSecOps, MLOps**

   * **보안/머신러닝 운영까지 확장된 개념**으로, 참조용.

---

## 7. 13주차: 시큐어 코딩 & 보안 관련 용어

1. **Secure Coding(시큐어 코딩) 정의**

   * **보안 취약점이 발생하지 않도록 코드를 작성하는 방법/가이드라인**.
   * “시큐어 코딩이 무엇인가?”를 한 문장 이상으로 설명할 수 있어야 함.

2. **보안 관련 핵심 용어 흐름**

   * **소프트웨어 결함 (software defect)**
     → **보안 결함 (security flaw)**
     → **취약점 (vulnerability)**
     → **익스플로잇 (exploit)**
     → **완화(mitigation)**
   * 중요한 포인트:

     * **취약점**: 해커가 악용 가능한 약점.
     * **익스플로잇**: 그 취약점을 실제로 악용해 보안 정책을 위반하는 행위/코드.
     * **완화**: 이미 존재하는 취약점이 악용될 때 피해를 최소화하기 위한 조치(툴, 가이드, 정책 등).
   * 이 흐름을 **한 줄 플로우로 설명하라고 할 수 있다**고 직접 말함.

3. **시큐어 코딩에서 다룬 다양한 문제 사례, 코드 규칙**

   * 입력 검증, 버퍼 오버플로, SQL Injection, XSS 등의 예시들.
   * **“좋은 코드의 특징, 시큐어 코딩 규칙, 리팩토링과의 연관”** 정도를 함께 이해.

4. **시험에서의 다루는 방식**

   * 시큐어 코딩도 **실습했으므로, 기본 개념·용어를 정확히 익히는 것**이 중요.

---

## 8. 디자인 패턴(14주차) — 시험의 핵심 (비중 최대)

교수님이 **“여기 비중이 50% 이상, 전체 30점 중 가장 큰 부분”**이라고 강조.

### 8-1. 디자인 패턴 개요

1. **디자인 패턴의 정의**

   * 반복되는 설계 문제에 대한 **재사용 가능한 해결책**.
   * **패턴 설명 항목들**: 이름, 목적, 동기, 구조, 참여 객체, 협력 방식, 결과 등(강의자료에 있는 항목들).

2. **3가지 큰 분류**

   * **생성(Creational)** 패턴
   * **구조(Structural)** 패턴
   * **행위(Behavioral)** 패턴

3. **각 분류별 패턴 수**

   * **생성 패턴: 5개**
   * **구조 패턴: 7개**
   * **행위 패턴: 11개**
     → 총 **23개 패턴**, 이 중 **18개(구조+행위)가 특히 헷갈리니 구분 연습 필요**라고 강조.

### 8-2. 시험에서 요구하는 수준

1. **각 패턴에 대해 요구되는 것**

   * 이 패턴이 **어느 분류(생성/구조/행위)에 속하는지**.
   * 패턴의 **핵심 아이디어/특징**을 설명할 수 있을 것.
   * 예: “**프로토타입 패턴을 설명하라**“ → 특징+역할+간단 예시.
   * 예: “**싱글톤 패턴을 설명하라**“
   * 예: 구조 패턴에서 “**브리지 패턴 설명**”, “**프록시 패턴과 퍼사드 차이**”, “**어댑터 패턴** 설명”.

2. **UML 다이어그램 / 코드 수준**

   * **UML 다이어그램이나 코드 구현까지는 시험에서 요구하지 않음**.
   * UML이나 샘플 코드는 **이해용 참고**일 뿐.
   * “**이 패턴에 대한 코드 예제를 작성하라**” 같은 문제는 **안 나온다고 못박음**.

3. **패턴 구분 연습**

   * 공부할 때 **“이 패턴은 생성/구조/행위 중 어디?”**를 항상 같이 붙여서 기억.
   * 시험에서 **설명이 주어지고, 이게 어떤 패턴인지 맞히는** 식이나,
     **패턴 이름을 주고 특징·용도를 쓰게 하는** 식 모두 가능.

4. **서로 헷갈리기 쉬운 패턴들 구분**

   * **Proxy vs Facade**

     * 둘 다 “앞단에 하나 더 둔다”는 느낌이 비슷하지만:
     * **Facade**: 복잡한 내부를 숨기고 **단순한 인터페이스 한 개** 제공.
     * **Proxy**: **접근 제어, 캐싱, 로깅 등**을 위해 대신 요청을 받아주는 대리 객체.
   * **Observer vs State**

     * Observer: 상태 변화 **알림/구독** 구조.
     * State: 내부 상태에 따라 **행동이 바뀌는 객체**.
   * **Strategy**

     * **알고리즘 군을 캡슐화**해서 런타임에 알고리즘을 바꾸는 패턴.
   * **Mediator**

     * 여러 객체 간 상호작용을 **중앙 조정자(중재자)**가 관리.
     * Proxy와도 헷갈릴 수 있으니 “**중재 구조 vs 단순 대리/접근제어**”로 구분.

5. **생성 패턴 5개는 상대적으로 구분이 쉽다고 언급**

   * 그래서 **5개 모두 이름·분류·핵심 특징**은 반드시 정리.
   * 나머지 구조 7개, 행위 11개는 **서로 비슷비슷해서 더 주의 깊게 정리**할 것.

6. **출제 방식**

   * **키워드만 묻는 단답형**도 있고,
   * “패턴 이름 → 개념/특징 서술” 형식도 있고,
   * 배점이 큰 문제는 **더 길고 자세히 쓸수록 가점**.
   * “기본 개념만 겨우 적은 답안”과 “예시까지 곁들여 잘 정리한 답안”의 점수 차이를 크게 두겠다고 언급.

---

## 9. 시험 준비 방법 관련해서 교수님이 강조한 것들

이것도 “시험 대비”와 직접 연결되므로 포함하겠습니다.

* **과제 잘 했다고 시험이 자동으로 잘 나오지 않는다**

  * 과제는 GPT/LLM 도움을 받을 수 있었지만,
  * **시험은 머릿속에 남은 개념을 글로 직접 써야 한다**는 점 강조.
* **개념·특징·장단점을 직접 손으로 써보며 연습**

  * 특히 SOLID, 품질 특성, 애자일 vs 전통, TDD 단계·장단점, XP, DevOps,
    시큐어 코딩 용어들, 각 디자인 패턴의 특징 등.
* **키워드 + 설명을 같이 쓰는 연습**

  * “이 용어가 나오면 한 두 줄 이상으로 설명할 수 있는지”가 핵심.

---

이게 녹음에서 교수님이 **“시험에 나온다/나올 수 있다”고 직접 언급하거나, 시험 대비라고 강조한 내용 전체**입니다.
이걸 그대로 체크리스트처럼 삼아서,

1. 각 키워드(용어) 리스트업
2. **정의/특징/장단점/비교**를 직접 적어보는 연습

만 해두면, 교수님이 말한 범위는 거의 다 커버된다고 보면 됩니다.
