# 09. 코딩 / 시큐어 코딩 정리
## 1. 왜 _시큐어 코딩_이 중요한가

- **운영 단계의 버그 = 단순 디펙트가 아님**
    - 개발 중 버그는 내부 테스트에서 잡히면 그나마 비용이 적다.
    - **서비스 운영 중 발생하는 버그/취약점**은
        - 서비스 중단, 데이터 유출, 금전 손실,
        - 회사 신뢰도 하락까지 이어짐.
- **취약점과 공격의 연결**
    - 코드 안의 작은 실수(버퍼 오버플로, 정수 오버플로… 등)가
    - 악성코드·공격자에게 **실행 지점**을 제공 → 시스템 장악, 정보 유출.
- **보안 투자의 어려움**
    - “보안 강화하면 뭐가 좋아졌는지 눈에 안 보임”.
    - 평소엔 조용하다가, 한 번 뚫리면 엄청난 피해.
    - 그래서 **개발 단계부터 품질·보안 코딩을 습관화**해야 함.

## 2. 핵심 개념 정리

- **Defect (결함)**
    - 요구사항/설계와 다르게 구현된 코드 상의 문제.
- **Vulnerability (취약점)**
    - 공격자가 악용하면 **보안 침해**로 이어질 수 있는 결함.
- **Exploit (익스플로잇)**
    - 취약점을 실제로 공격에 사용하는 구체적 방법/코드.
- **Mitigation (완화 정책)**
    - 이미 배포된 코드를 바로 고치기 어려울 때,
        - 방화벽 설정, 입력 필터링, 권한 제한 등으로
        - 피해를 줄이는 방어적 조치.

## 3. C / C++ 언어의 위험 요소
### 3.1 정수 타입 & 형변환

- **데이터 크기 차이**
    - `long`, `int`, `short`, `char` 등 크기가 서로 다름.
    - 큰 타입 → 작은 타입으로 캐스팅 시 **잘림(truncation)** 가능.
- **부호 유무**
    - `signed` vs `unsigned` 간 형변환 시
        - 원래 음수가 큰 양수로 바뀌는 등, 예상 못 한 값이 나올 수 있음.
- **자동 형변환 (integer promotion)
    - 연산 중 컴파일러가 자동으로 타입을 승격/변환.
    - 개발자가 의도하지 않은 타입 변경으로 **비정상 연산 결과** 발생.
- **정수 오버플로**
    - `INT_MAX + 1` 같은 연산은 범위를 넘어가며 wrap-around.
    - 인덱스 계산, 길이/크기 계산, 메모리 할당 크기 계산 등에서 치명적.

> ⇒ 정수 연산 전에/후에 **범위 체크**가 필수.

### 3.2 문자열 처리 취약점

- C 문자열 = **char 배열 + 마지막에 `'\0'` (널 문자)**.
- 문제 패턴:
    - 목적 버퍼 크기보다 더 많이 복사 (`strcpy`, `gets` 등 무제한 복사).
    - 널 종료(`'\0'`)를 안 넣어서 이후 함수들이 끝을 못 찾음.
- 결과:
    - 스택/힙의 인접 메모리를 덮어써서
        - 프로그램 오동작, 크래시,
        - 리턴 주소/함수 포인터까지 덮으면 **임의 코드 실행** 가능.
- 권장 사항:
    - 길이 인자가 있는 함수 사용: `strncpy`, `snprintf` 등.
    - 가능하면 `_s` 계열(언더바 s) 안전 함수 사용 (컴파일러/플랫폼 지원 시).
    - 직접 만든 함수에도 **버퍼 길이 파라미터**를 반드시 포함시킨다.

## 4. 메모리 할당/해제 시 주의점
### 4.1 malloc / calloc / realloc / free

- `malloc(size)`
    - 단지 **공간만 할당**, 내부 값은 **초기화되지 않음** (쓰레기 값).
- `calloc(n, size)`
    - `n*size` 만큼 할당 + **0으로 초기화**.
- `realloc(ptr, new_size)`
    - 기존 블록을 재사용/이동하며 크기 변경. 실패 시 NULL 가능.
- `free(ptr)`
    - 할당된 메모리 해제. 이후 그 포인터는 **더 이상 유효하지 않음**.

### 4.2 전형적인 메모리 오류들

1. **초기화 안 함**
    - `malloc` 후 바로 읽기 → 쓰레기 값 사용.
    - 로컬 변수 선언 후 초기값 없이 사용.
2. **리턴값(NULL) 미체크**
    - 메모리 부족 등으로 `malloc`이 `NULL` 반환 가능.
    - NULL 포인터에 접근하면 crash.
3. **use-after-free**
    - `free(ptr)` 한 뒤에도 `ptr`을 계속 사용.
    - 이미 다른 용도로 재할당된 메모리를 엉뚱하게 건드릴 수 있음.
4. **double free**
    - 같은 포인터를 두 번 `free` → 힙 구조 손상.
5. **memory leak**
    - 할당해 놓고 `free`를 안 하고 함수/루프를 빠져나감.

> ⇒ `malloc` 후:
> - **NULL 체크**
> - **초기화 (for문 / memset / calloc 사용 등)**
> - 사용이 끝나면 정확히 한 번만 `free`
> - `free` 후에는 `ptr = NULL`로 두어 이후 사용을 막는 습관

## 5. “좋은 코드”를 위한 3가지 기본 습관

교수님이 계속 강조한 **세 가지 체크 포인트**:
1. **입력/파라미터 유효성 검사**
    - 타입이 맞는지? (`int` 자리에 이상한 값?)
    - 값의 범위가 적절한지? (min/max, 음수 허용 여부 등)
    - 배열 인덱스, 길이 인자 등은 항상 상/하한 체크.
2. **모든 변수 초기화**
    - 로컬 변수, 구조체, 배열, 동적 할당 메모리 모두.
    - “귀찮더라도” 습관적으로 초기값을 넣는 연습.
3. **함수 리턴값 확인
    - 라이브러리 문서에서 **리턴값의 의미**를 확인.
    - 정상/오류 코드 외에 “예외 케이스”까지 고려.
    - 리턴값이 명세와 다른 이상 값일 때를 대비한 방어 코드(로그, 예외 처리 등).

> 이 세 가지만 꾸준히 지켜도 **디펙트·취약점의 상당 부분을 줄일 수 있다**는 메시지.

## 6. 방어적 프로그래밍(Defensive Programming)

- “항상 **비정상 케이스가 나올 수 있다**고 가정하고 코딩하라.”
    - 입력이 항상 정상이라는 가정 X.
    - 메모리가 항상 충분하다는 가정 X.
- 예:
    - 나누기 연산: 분모가 0인지, 혹은 특정 경계 값인지 확인.
    - 정수 연산: 연산 전후로 범위 초과 여부를 미리 체크.
    - 포인터: NULL 여부, 범위 검사 등을 먼저 수행.

## 7. 로그 · 디버깅 · 테스트
### 7.1 디버깅

- IDE의 **브레이크포인트 디버거** 활용:
    - 변수 값, 스택 프레임, 흐름을 단계별로 확인.
- `printf` 디버깅:
    - 간단하지만 과도하면 **성능 저하** 및 코드 오염.
    - 꼭 필요한 지점에만 사용하거나, 로그 레벨과 연동.

### 7.2 로그(Level) 설계

- 로그 레벨 예: `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL` …
- 운영 환경:
    - 평소에는 INFO/WARN 정도만,
    - 장애 분석 시 환경 변수/설정으로 레벨 올려서 DEBUG까지 출력.

### 7.3 테스트 관점

- **정상 케이스 + 비정상(에러) 케이스**를 모두 테스트해야 함.
- 단위 테스트, TDD 등은 별도의 강의에서 더 다룸(여기선 “품질을 높이는 도구” 정도로 언급).

## 8. 코드 리뷰와 코딩 표준
### 8.1 코드 리뷰의 목적

- **버그 발견** 뿐 아니라:
    - 코딩 스타일/가독성 향상,
    - 설계 의도와 구현의 일치 여부 확인,
    - 팀 내 지식 공유.
- 효과적인 코드 리뷰를 위해:
    - 리뷰 **목적과 범위**를 사전에 공유 (예: 로직 검증 vs 스타일 점검).
    - 리뷰어는 해당 기능/도메인을 어느 정도 이해한 상태에서 참여.

### 8.2 리뷰 시 기본 체크 항목

- 파라미터/입력 **타입·범위 검사**가 있는가?
- 변수 **초기값**을 주고 있는가?
- **리턴값**을 모두 확인하고 있는가?
- 예외 상황/에러 처리 로직은 있는가?
- 불필요하게 복잡한 로직, 중복 코드, 마법 숫자 등은 없는가?

## 9. 참고 자료 & 가이드

강의에서 언급된 대표 참고 자료들:
1. **KISA(한국인터넷진흥원)**
    - 언어별 시큐어 코딩 가이드 (C, Java, Python, JavaScript 등).
    - 「소프트웨어 개발 보안 가이드」 – 설계/구현 단계별 보안 요구사항 정리.
2. **SEI CERT Coding Standard**
    - C/C++, Java 등 언어별로 **안전하지 않은 코드 + 안전한 수정 예시**를 정리한 표준.
3. **CWE Top N 취약점 목록**
    - 매년 공개되는 주요 소프트웨어 취약점 카탈로그.
4. **Clean Code / 코딩 스타일 가이드**
    - 클린 코드(책), 구글 스타일 가이드, 각 회사별 코딩 규칙 등.
    - 목적: **단순하고 읽기 좋은 코드**, 유지보수가 쉬운 구조를 만드는 것.

## 10. 디자인 패턴과의 연결 (간단 언급)

- 시큐어 코딩/코딩 가이드는 **“버그와 취약점 줄이기”**에 초점.
- **디자인 패턴**은
    - 객체지향 설계 품질(유연성, 재사용성, 확장성)을 높이기 위한 “구조적인 해법” 모음.
    - GoF 패턴을 **생성(Creational) / 구조(Structural) / 행위(Behavioral)** 3가지로 분류.
- 실제 현업에서는
    - **코딩 표준 + 시큐어 코딩 + 디자인 패턴**을 함께 사용해
    - 품질과 보안을 동시에 끌어올리는 방향으로 발전하고 있다는 맥락.

## 11. 실무/취업 관점 포인트

- 자신의 프로젝트/과제에서:
    - “어떤 버그/문제가 있었는지”
    - “어떻게 분석하고 해결했는지”
    - “그 과정에서 무엇을 배웠는지” 를 정리해 두면, **면접에서 강력한 에피소드**가 됨.
- 특히:
    - 입력 검증, 초기화, 리턴값 체크, 로그/디버깅 활용, 코드 리뷰 경험 등은
    - 개발자로서 **성숙한 태도**를 보여주는 좋은 소재.