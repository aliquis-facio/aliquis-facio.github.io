# 소프트웨어 디자인패턴  
## 1. 생성(Creational) 패턴

> **목적:** 객체 “생성 방법”을 캡슐화해 **결합도↓**, **테스트 용이성↑**, **확장성↑**.

### 1.1. Singleton

- **의도:** 인스턴스를 하나로 제한하고 전역 접근점 제공.
- **언제:** 전역 설정, 캐시, 커넥션 풀 메타데이터 등 **진짜로 단일**해야 할 때.
- **장점:** 인스턴스 일관성, 지연 초기화 가능.
- **주의:** 전역 상태 증가, 테스트 격리/동시성 문제. **DI/컨테이너가 대안**이 되는 경우가 많음.

### 1.2. Factory Method

- **의도:** “무엇을 만들지”를 **서브클래스**가 결정(생성 훅 제공).
- **언제:** 상위 타입은 생성 규약만 알고, 구상 제품이 다양할 때.
- **장점:** 개방-폐쇄 원칙(OCP) 지원, 생성 로직 분리.
- **주의:** 서브클래스/클래스 수 증가, 단일 제품 단위에 적합.

### 1.3. Abstract Factory

- **의도:** **제품군(세트)**을 일관되게 생성(예: OS 위젯 테마 묶음).
- **언제:** 서로 맞물린 여러 제품을 **같은 패밀리**로 만들어야 할 때.
- **장점:** 제품간 일관성 보장, 교체 용이(테마/플랫폼 전환).
- **주의:** 추상화 층 증가, 제품군 다양성 관리 비용.

### 1.4. Builder

- **의도:** 복잡한 객체를 **단계별 조립**(필수/옵션 분리, 가독성↑).
- **언제:** 생성자 파라미터가 많거나, 조립 순서·검증이 필요한 불변 객체.
- **장점:** 가독성, 유효성 검증, 동일 프로세스로 다른 표현물 생성 가능.
- **주의:** 클래스 수 증가, 간단한 객체엔 과도.

### 1.5. Prototype

- **의도:** 기존 객체를 **복제(clone)** 해 생성 비용 절감/런타임 스펙 복제.
- **언제:** 초기화 비용이 큰 객체, 구조/설정이 복잡하고 자주 비슷하게 필요할 때.
- **장점:** 성능(빠른 생성), 런타임에 새 “형판”을 학습/주입 가능.
- **주의:** 깊은/얕은 복사 이슈, 순환 참조/불변성 주의.

### 1.6. Object Pool

- **의도:** 재사용 가능한 인스턴스 **풀**로 생성·파괴 비용 절감.
- **언제:** 생성이 비싼 리소스(소켓, 채널) 다량 사용 시.
- **주의:** 누수/반납 관리, 동시성·수명 주기 복잡도↑. 현대 런타임/커넥션 풀 제공 시 중복 가능.

## 2. 구조(Structural) 패턴

> **의도:** 클래스/객체를 **조합**해서 인터페이스 불일치 해결, 복잡성 은닉, 기능 합성으로 **유연성↑·결합도↓**.

### 2.1. Adapter

- **의도:** 기존 대상(Target)과 호환되지 않는 인터페이스를 **변환**.
- **언제:** 레거시/서드파티 API 붙일 때, 내부 도메인 모델 바꾸지 않으려 할 때.
- **포인트:** 클래스 어댑터(상속) vs 객체 어댑터(위임; 일반적).
- **주의:** 도메인 불일치를 억지로 숨기면 “안티-코럽션 레이어”로 격상 고려.

### 2.2. Bridge

- **의도:** **추상(Abstraction)**과 **구현(Implementor)**을 분리해 **독립 확장**.
- **언제:** 변화 축이 2개 이상(예: 디바이스 × 프로토콜)이라 곱셈적 클래스 폭증 우려.
- **포인트:** 설계 시점부터 분리. Adapter는 사후 호환, Bridge는 사전 분할.
- **효과:** OCP, 테스트 용이(각 축 모킹).

### 2.3. Composite

- **의도:** 부분–전체 트리 구조를 동일 인터페이스로 다룸(재귀 연산).
- **언제:** 메뉴/파일시스템/GUI 위젯 트리/장면 그래프.
- **포인트:** `Leaf`와 `Composite`를 동일하게 취급(동일 연산).
- **주의:** Leaf에서 무의미한 연산 노출 지양(안전 합성).

### 2.4. Decorator

- **의도:** 런타임에 객체에 **행동을 덧입힘**(래핑).
- **언제:** 로깅/캐시/리트라이 등 횡단 관심사를 조합적으로 적용.
- **포인트:** 합성>상속. 체인 **순서가 의미**를 가짐.
- **주의:** 래퍼 지옥(깊은 포장) → 명명된 데코레이터/빌더로 관리.

### 2.5. Facade

- **의도:** 복잡한 서브시스템에 **단순한 창구** 제공.
- **언제:** 외부 공개 API, 모듈 경계 정리, 레거시 캡슐화.
- **포인트:** 얇고 고수준. 내부 세부는 은닉하되, 필요 시 직접 접근 허용 가능.
- **주의:** 거대 파사드(갓 오브젝트) 금지—사용자 시나리오 단위로 분리.

### 2.6. Flyweight

- **의도:** **내재 상태**(공유 가능) 캐시·공유로 메모리 절감, **외재 상태**는 호출자가 제공.
- **언제:** 수십만 개 유사 객체(문자 글리프, 타일/아이콘).
- **주의:** 스레드 안전, 식별(identity) 혼동, 외재 상태 누락 방지.

### 2.7. Proxy

- **의도:** 원본과 **동일 인터페이스**로 **접근 제어/지연 로딩/원격 호출/캐시**.
- **종류:** Virtual/Remote/Protection/Caching/Logging/Smart Reference 등.
- **주의:** 숨은 네트워크 지연·에러 전파 정책, 캐시 일관성.

## 3. 행동(Behavioral) 패턴

> **의도:** 객체 간 **역할·책임·협력**을 구조화해 변경에 강하고 테스트 가능한 상호작용을 만든다.

### 3.1. Chain of Responsibility (CoR)
    
- **의도:** 요청을 핸들러 **연쇄**로 전달하며 처리/패스.
- **언제:** 미들웨어/필터 파이프라인(인증→권한→레이트리밋).
- **포인트:** 순서가 의미 있음, 동적 추가 용이.

### 3.2. Command
    
- **의도:** 요청을 **객체**로 캡슐화(큐잉, 재시도, Undo).
- **언제:** 작업 기록/스케줄/멱등 재실행 필요.
- **포인트:** Invoker–Command–Receiver 분리.

### 3.3. Interpreter
    
- **의도:** 간단한 **DSL**을 파싱·평가.
- **언제:** 규칙식, 조건부 자동화, 쿼리 미니언어.
- **포인트:** 문법 복잡해지면 Parser/Visitor와 결합.

### 3.4. Iterator
    
- **의도:** 컬렉션 구조 노출 없이 **순회**.
- **언제:** 다양한 컨테이너를 통일된 방식으로 탐색.
- **포인트:** 지연(iterable)로 메모리 절감 가능.

### 3.5. Mediator
    
- **의도:** 동료 객체 간 상호작용을 **허브**가 조정.
- **언제:** N:N 상호참조로 복잡도가 폭증할 때.
- **포인트:** 동료는 Mediator만 알도록 의존 축소.

### 3.6. Memento
    
- **의도:** 내부 상태를 **스냅샷**으로 저장/복원.
- **언제:** Undo, 롤백, 타임트래블 디버깅.
- **포인트:** 캡슐화 유지(Originator가 스냅샷 생성).

### 3.7. Observer (Publish–Subscribe)
    
- **의도:** 주체 상태 변화 → **구독자**에 통지.
- **언제:** 이벤트 스트림, UI 바인딩, 리액티브.
- **포인트:** 느슨한 결합, 구독 해지/역참조 누수 주의.

### 3.8. State
    
- **의도:** **상태 객체**로 행동을 교체(FSM).
- **언제:** 상태 전이에 따라 규칙·행동이 달라질 때.
- **포인트:** 분기 제거, 전이 표/가드 조건 명시.

### 3.9. Strategy
    
- **의도:** **알고리즘 교체 가능** 인터페이스.
- **언제:** 정책/휴리스틱을 런타임 선택.
- **포인트:** 컨텍스트는 전략의 생애/선택만 관리.

### 3.10. Template Method
    
- **의도:** 알고리즘 **골격**을 정의하고 훅으로 부분만 재정의.
- **언제:** 공통 절차 + 변하는 일부.
- **포인트:** 상속 기반(추상 클래스), 과도한 훅 남용 금지.

### 3.11. Visitor
    
- **의도:** 구조는 고정, **연산을 후첨**(이중 디스패치).
- **언제:** 복잡한 계층/AST에 다양한 연산 추가.
- **포인트:** 요소 추가는 비용↑, 연산 추가는 용이.