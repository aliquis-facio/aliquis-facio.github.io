# TDD(Test-Driven Development)

- **TDD = “테스트(요구사항)를 먼저 코드로 박아두고, 그 테스트를 하나씩 초록으로 만들면서 설계를 다듬어 가는 개발 문화”** 이다.
- 초반에는 낯설고 비용이 커보이지만, 잘 자리 잡으면 **품질·협업·자신감**을 동시에 높여주는 방식이며, 자동화 도구와 페어 프로그래밍·LLM을 활용하면 실무/학습에서 훨씬 수월하게 적용할 수 있다.

## 1. TDD란 무엇인가

- **정의**
    - 테스트 코드를 먼저 작성하고, 그 테스트를 통과시키는 최소한의 구현 코드를 작성하는 개발 방법론.
    - 한국어로는 **테스트 주도 개발**. “테스트가 주도권을 쥐고, 개발은 그 테스트를 통과시키며 따라가는 방식”으로 설명.
- **배경**
    - 익스트림 프로그래밍(XP)의 “테스트 우선” 접근에서 발전.
    - 요구사항을 곧 **테스트로 명세**하고, 이를 하나씩 통과시키며 기능을 점진적으로 완성한다.

## 2. TDD의 핵심 철학

- **테스트 = 요구사항 명세**
    - 테스트는 “이 시스템이 무엇을 해야 하는가”를 가장 구체적으로 나타내는 명세 역할을 한다.
- **실패하는 테스트의 의미**
    - 아직 구현되지 않았거나, 버그가 있다는 **경고·개선 신호**다.
- **최소한의 코드**
    - 테스트를 통과하는 데 필요한 **가장 단순한 코드만** 우선 작성한다. 그 결과 구조가 자연스럽게 단순·명확해진다.

## 3. Red → Green → Refactor 사이클

1. 🟥 **Red (실패)**
    - 아직 구현되지 않은 기능에 대한 **실패하는 테스트**를 먼저 작성.
    - 테스트를 돌리면 당연히 전부 실패(빨간 막대). 이 실패가 “해야 할 작업 목록”이 된다
2. 🟩 **Green (성공)**
    - 테스트를 통과시키는 **최소한의 코드**를 작성한다. “일단 돌아가게 만드는 단계”에 집중.
3. 🟦 **Refactor (리팩터링)**
    - 테스트가 초록(Green)인 상태를 유지하면서 **중복 제거, 성능·가독성 개선, 모듈화**를 수행.
    - 이 주기를 계속 반복하며 기능을 확장.

## 4. 전통적 개발 vs TDD

- **전통 개발**
    - 요구사항 → 설계/코드 → 테스트(대부분 사후) 순서.
    - 구현 위주로 달리다가, 마지막에 테스트를 한꺼번에 붙여서 **후반부 디버깅 부담**이 크다.
- **TDD**
    - 테스트 → 코드 → 리팩터링 순서. 테스트가 **개발의 첫 단계이자 종료 조건**이 된다.
    - 구현하면서 계속 테스트를 돌리기 때문에, **초기부터 지속적인 피드백**을 받으며 오류를 조기에 잡는다.

## 5. Robert C. Martin(언클 밥)의 TDD 3법칙

1. **테스트 없이 코드부터 작성하지 말 것**
2. **실패할 만큼만 테스트 작성**
    - 컴파일 오류까지 포함해서, **일단 실패하는 테스트**를 만든다.
3. **현재 실패한 테스트를 통과할 최소 코드만 작성**
    - 과도하게 미리 구현하지 말고, **지금 눈앞의 빨간 테스트 하나를 초록으로 만드는 데 집중**.
실패한 테스트는 **진보의 신호**이며, 이를 통과시키는 과정이 곧 리팩터링과 설계 개선을 촉진한다.

## 6. TDD의 주요 장점
- 품질 & 효율
	- 높은 코드 품질과 테스트 커버리지 확보.
	- 구조가 모듈화·단순화되어 유지보수가 쉬운 설계로 유도.
	- 빠른 피드백으로 오류를 **초기에 발견**해, 뒤늦은 디버깅/버그 수정 비용을 줄인다.
	- 테스트가 “안전망” 역할을 하기 때문에 리팩터링 시 안심하고 구조를 고칠 수 있다.
- 협업 & 지식 공유
	- 테스트 코드가 **실행 가능한 문서** 역할을 해서, 새로 들어온 개발자가 기능을 이해하기 쉽다.
	- API 사용 예제, 엣지 케이스가 모두 테스트에 드러나므로 재사용성과 팀 내 일관성이 강화된다.
	- 수업에서는 **2명이 페어를 이루어** 서로의 기능·테스트 케이스를 공유하고, LLM에게 기능 설명을 던져 테스트 케이스를 제안받은 뒤 서로 비교·토론해 보는 실습을 권장했다.
- 개발자 자신감
	- “이 테스트 세트가 모두 초록이면, 적어도 이 범위의 오류는 막았다”라는 확신을 주기 때문에, 배포와 유지보수에 대한 **심리적 부담이 줄어든다**.

## 7. TDD 실천 원칙
- 작은 단위, 자주 실행
	- **작은 단위(Unit)** 의 테스트를 자주 돌리는 것이 기본.
	- 테스트는 **FIRST 원칙**을 지키는 것이 좋다:
	    - Fast(빠르게)
	    - Independent(독립적으로)
	    - Repeatable(반복 가능)
	    - Self-validating(수동 검사 불필요)
	    - Thorough(충분한 범위).
- 테스트 코드 구조 & 네이밍
	- 테스트 이름은 “어떤 동작을 검증하는지”가 드러나게 짓는다.
	- 구현 코드와 테스트 코드는 디렉터리/패키지 수준에서 분리 (`src` vs `test`)하고, **한 테스트는 한 기능만 검증**하도록 만든다.
	- 테스트는 서로 의존성이 크지 않게 독립적으로 작성해야, 실패 원인을 빠르게 찾을 수 있다.
- Mock 객체와 외부 의존성 최소화
	- DB, 외부 API, 파일 시스템처럼 느리고 불안정한 의존성은 **Mock 객체**로 대체해 테스트가 빠르고 예측 가능하게 만든다.
	- Mock를 사용하면 테스트가 독립적으로 실행되고, 실패 원인도 구현 로직에 집중해서 볼 수 있다.
- 다양한 테스트 레벨
	- 단위(Unit) 테스트 외에도 **통합 테스트, 회귀 테스트**를 병행해 전체 품질을 확보해야 한다.
	- 특히 코드 변경 시 자동으로 돌리는 회귀 테스트 세트가 중요하다.

## 8. 테스트 시나리오 · 테스트 케이스 · 테스트 코드

- **테스트 시나리오(Test Scenario)**
    - “회원 로그인 기능이 정상적으로 동작하는가?”처럼 사용자의 실제 사용 흐름을 상위 수준에서 기술한 것.
- **테스트 케이스(Test Case)
    - 시나리오를 **입력 값, 실행 절차, 기대 결과**로 쪼갠 구체적인 항목.
    - 예:
        - TC-001 정상 로그인: ID=`admin`, PW=`1234` → “로그인 성공” 메시지 및 대시보드 이동 기대.
        - TC-002 비밀번호 오류: ID=`admin`, PW=`wrong` → “비밀번호가 틀렸습니다” 메시지 기대.
- **테스트 코드(Test Code)**
    - 위 테스트 케이스를 `unittest`, `pytest` 같은 테스트 프레임워크로 구현한 실제 코드.
    - 코드 변경 때마다 자동으로 돌려 보는 **회귀 테스트** 역할을 한다.
- 흐름 정리:
    - **시나리오 → 여러 테스트 케이스 → 각 케이스를 구현한 테스트 코드** 순서로 연결된다.
	
## 9. TDD의 도전과 한계

- **초기 비용·학습 곡선이 크다**
    - 요구사항을 시나리오/테스트 케이스로 정리하고, 테스트 코드를 먼저 쓰는 과정 때문에, **처음에는 개발 시간이 2~3배 걸리는 느낌**을 받을 수 있다.
- **레거시 코드에는 적용이 어렵다**
    - 기존에 테스트가 거의 없는 거대한 코드베이스에 TDD를 그대로 적용하기는 현실적으로 쉽지 않다.
- **테스트 작성 오버헤드**
    - 기능이 수십 개, 수백 개가 되면 테스트 케이스도 매우 많아져서 “노가다 같다”고 느끼기 쉽다. 그래서 자동화 도구와 전략적인 테스트 선정이 중요하다.
- **단위 테스트만으로 전체 품질 보장은 불가**
    - TDD는 주로 단위 수준에서 강력하지만, 성능·보안·사용성·통합 이슈까지 모두 커버하지는 않는다. 다른 테스트와 함께 써야 한다.