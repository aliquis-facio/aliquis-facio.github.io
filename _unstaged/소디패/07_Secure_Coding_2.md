# Secure Coding in C/C++ 
## 1. 보안 개념과 위협(Threats)
### 1.1. 위협의 정의

- **위협(Threat)**: 과거 공격의 근원이었거나, 앞으로 공격의 근원이 될 수 있는 **사람 / 그룹 / 조직 / 외부 압력**.
    - 예: 해커, 내부자, 범죄자, 경쟁 정보 전문가, 테러리스트, 정보 전사 등.

### 1.2. 소프트웨어 보안(Software Security)과 CERT/CC

- **CERT/CC**(컴퓨터 비상 대응팀 조정 센터)
    - 취약점 정보 수집·관리
    - 공개 전 자료 검토
    - 정기적인 취약점 보고
- **소프트웨어 보안**
    - _개발적인 측면_: 시큐어 디자인 + 결함 없는 구현
    - _운영적인 측면_: 안전한 분산 시스템·네트워크 구성

### 1.3. 보안 정책(Security Policy)

- **보안 정책**
    - 민감한 자원을 어떻게 보호할지 정한 **규칙과 관행(규범)** 의 집합.
    - 문서화해서 **명시적으로 공유**할수록 사용자 행동을 예측하고 통제하기 쉽다.

### 1.4. 보안 결함·취약점·익스플로잇·완화

- **소프트웨어 결함(Software Defect)**
    - 개발 과정 어디서든 생길 수 있는 일반적인 버그.
- **보안 결함(Security Flaw)**
    - 잠재적인 보안 위협을 가진 결함.
- **취약점(Vulnerability)**
    - 공격자가 **명시적/암시적 보안 정책을 위반**할 수 있게 만드는 조건의 집합.
    - 모든 보안 결함이 곧바로 취약점은 아니다.
- **익스플로잇(Exploit)**
    - 취약점을 실제로 이용해 정책을 위반하는 기술(웜, 바이러스, 트로이 목마 등).
- **완화(Mitigation)**
    - 취약점 악용을 어렵게 만드는 회피 방법 혹은 임시 해결책.
    - 예: 무제한 문자열 복사를 길이 제한 버전으로 교체, 특정 포트 차단, 트래픽 필터링.

> **프로그램 소스 → 소프트웨어 → 컴퓨터 시스템 → 네트워크**로 이어지는 흐름 속에서  
> ‘보안 결함 → 취약점 → 익스플로잇 → 공격’ 라인이 어떻게 연결되는지를 한 번에 보여줌.

## 2. 왜 C / C++ 에서 보안 문제가 많은가
### 2.1. C/C++의 특징

- 매우 널리 쓰이는 언어.
- CERT/CC에 보고된 **취약점의 상당수**가 C/C++ 프로그램에서 발생.

### 2.2. C 언어의 구조적인 문제

- C는 **개발자를 보호해주는 장치가 거의 없음**.
    - 배열 경계 체크, 타입 체크 등을 자동으로 잘 안 해줌.
- 프로그래머가 “컴파일러/언어가 알아서 해주겠지”라고 생각하고 체크 로직을 안 넣으면 그대로 취약점으로 이어짐.

### 2.3. 대표적인 프로그래머 실수

- 배열 인덱스를 범위 밖으로 사용
- 정수 오버플로/트렁케이션
- 함수 호출 시 파라미터 잘못 사용
- 부호/크기가 다른 정수 타입(signed/unsigned, 길이 다른 타입)을 섞어서 쓰기 → 예기치 않은 결과(unrepresentable result).

### 2.4. 레거시 코드(Legacy Code)

- 표준이 지금처럼 엄격해지기 전에 작성된 **오래된 C 코드**가 많음.
- 당시에는 컴파일러 경고도 느슨, 코딩 습관도 덜 엄격 → **보안 위험에 더 많이 노출**.

## 3. 정수(Integer)와 보안
### 3.1. 정수 표현과 범위

- 다양한 정수 타입: `signed char`, `short`, `int`, `long`, `long long` 등.
- 각 타입마다 **표현 가능한 최소/최대 값**이 다름.
- 슬라이드의 표(18p)는 C 표준 타입별 최소 크기와 범위를 정리. (예: `CHAR_BIT >= 8`, `short` 최소 16비트, `int` 최소 16비트, `long` 최소 32비트 등)
- **랩어라운드(wrap-around)** 그림(19p)
    - 4비트 **부호 없는 정수** 기준: 0~15가 원형으로 이어져 있음.
    - 15에 1을 더하면 0으로 돌아가는 식의 현상 → 오버플로 시 값이 튀는 이유.

### 3.2. 정수 변환(Integer Conversions)과 프로모션

- “변환” = 대입, 형변환, 계산 결과를 **다른 정수형**으로 바꾸는 것.
- 작은 타입 → 더 큰 타입으로 변환 시: 보통 값이 잘 보존됨.
- 큰 타입 → 작은 타입 변환 시: **상위 비트를 잃어버리면서 값이 망가질 수 있음**.
- **정수 프로모션(Integer Promotions)**
    - `int`/`unsigned int`보다 _순위가 낮은 타입_이 연산에 쓰이면 자동으로 `int` 또는 `unsigned int`로 승격.
    - 부호를 포함해 값을 보존하는 방향으로 변환 규칙 존재.
- 슬라이드의 두 개 표(25–26p)는
    - `char → short`, `short → long`, `unsigned short → int` 등
    - 타입 쌍마다 **sign-extend / zero-extend / 하위 바이트 보존** 등 어떤 방식으로 비트가 변환되는지 정리.
- 관련 CERT 규칙
    - `INT31-C` : 정수 변환으로 데이터 손실·오동작이 생기지 않도록.
    - `INT35-C` : 필요한 만큼 정확한 정밀도의 정수 타입을 사용.

### 3.3. 연산 시 주의 사항

- **오버플로/언더플로** 항상 고려
- `%` 연산자는 정수형에만 사용 가능 (실수에 사용 X)
- 연산자 우선순위, 결합 방향에 따라 값이 달라질 수 있음.
- CERT 규칙
    - `INT30-C` : unsigned 정수 연산이 wrap되지 않도록.
    - `INT32-C` : signed 정수 연산이 오버플로되지 않도록.

### 3.4. 정수 오류 유형

- **Overflow** : 범위를 넘어서 wrap-around 발생
- **Sign error** : 부호 해석이 바뀌는 오류
- **Truncation** : 상위 비트 잘려 나가면서 값 손실

## 4. 문자열(Strings)과 버퍼 오버플로
### 4.1. 문자열 입력의 위험성

- 문자열은 커맨드 라인, 환경 변수, 콘솔 입력, 파일, 네트워크 등 **외부 입력**에서 유입됨.
- 입력 내용에 따라 프로그램의 동작이 달라지기 때문에 **보안상 가장 민감한 데이터** 중 하나.

### 4.2. C vs C++ 문자열

- **C-style string**
    - `'\0'`(널 문자)로 끝나는 **문자 배열**.
    - 길이: 널 포함 바이트 수 / 값: 문자 시퀀스 자체.
- **C++ string**
    - `std::string`, `std::wstring` 등 템플릿 클래스로 제공.
    - C 스타일 문자열과 **직접적 상호운용이 안 됨**(변환 필요).

### 4.3. 문자열 잘림(Truncation)과 안전 함수

- `strncpy`, `fgets`, `snprintf` 등 **길이 제한 함수**를 사용하면
    - 버퍼 오버플로는 완화되지만, **너무 긴 입력은 잘려서 들어갈 수 있음**.
- 문자열 잘림 → 중요 데이터 일부가 사라지거나, 프로토콜/포맷이 깨져서 다른 문제 발생 가능.
- CERT 규칙 예
    - `MSC34-C` : 폐기되었거나 평판이 안 좋은 함수(대표적으로 `gets`, 무제한 `strcpy` 등)를 쓰지 말 것.
    - `STR35-C` : 경계가 없는 소스에서 고정 길이 배열로 복사하지 말 것.

### 4.4. 버퍼 오버플로(Buffer Overflow)

- 정의: 데이터가 **할당된 메모리 경계 밖으로** 써질 때 발생. (슬라이드 32p 그림)
- C 표준 라이브러리 함수 중 일부는
    - 경계 체크 없이 복사/포맷(예: `gets`, 옛날 `strcpy`, `sprintf`)
    - 이를 부주의하게 쓰면 스택/힙의 다른 영역까지 덮어씀.

#### 4.4.1. 스택 예제 (Password)

```c
char Password[8];
gets(Password);
if (!strcmp(Password, "badprog")) ...
```

- 8바이트 버퍼에 7자 + `'\0'`까지만 안전.
- 그 이상을 입력하면:
    - return address, saved frame pointer 등 **스택의 다른 데이터까지 덮어씀**. (35, 37p 스택 그림)
- 이 메커니즘이 공격자가 **리턴 주소를 조작해 쉘코드 실행** 등에 쓰는 전형적인 스택 오버플로 취약점 구조.

### 4.5. 문자열 관련 완화 전략

- 국제 표준(ISO/IEC TR 24731, C11 등)에서 **덜 위험한 함수들** 지정:
    - `strcpy_s`, `strcat_s`, `strncpy_s`, `strncat_s` 등.
- 슬라이드 표(39p)는 각 함수가
    - 버퍼 오버플로 보호 여부
    - 널 종료 보장 여부
    - 잘림 가능 여부
    - 동적 메모리 할당 여부
    - 런타임 제약 검사 여부  
        를 정리.

> ⇒ **원칙**:
> - 입력 길이 검증 + 안전 함수 사용
> - 버퍼 크기와 널 종료를 항상 고려

## 5. 동적 메모리 관리와 오류
### 5.1. C / C++ 메모리 할당 인터페이스

- C
    - `calloc(n, size)` : n*size 할당 + 0으로 초기화
    - `malloc(size)` : size만큼 할당(초기화 X)
    - `realloc(ptr, new_size)` : 크기 변경
    - `free(ptr)` : 해제
- C++
    - `new` / `delete` 연산자 사용.

### 5.2. 전형적인 동적 메모리 오류들

1. **초기화 안 된 메모리 사용**
    - `malloc()`은 단지 “공간만 할당” → 내부 값은 쓰레기.
    - “malloc이 0으로 채워줄 것”이라는 착각이 흔함.
    - 해결: `memset()`으로 초기화하거나, 0으로 초기화된 블록이 필요하면 `calloc()` 사용.
    - CERT: `EXP33-C` – 초기화되지 않은 메모리를 읽지 말 것.
2. **반환값(NULL) 미체크**
    - `malloc`, `calloc`, `realloc`이 실패하면 **NULL 포인터 반환**.
    - NULL 체크 없이 사용 → NULL 역참조로 크래시.
    - CERT: `EXP34-C` – NULL 포인터 역참조 금지.
3. **해제된 메모리를 다시 참조(use-after-free)**
    - `free(ptr)` 후 `ptr`을 그대로 두면, 이후 코드에서 여전히 접근할 수 있음.
    - 메모리 관리자가 그 영역을 재사용할 수 있으므로 **증상이 즉시 안 나타나고**, 나중에 이상한 동작 발생 → 디버깅 매우 어려움.
4. **같은 메모리를 여러 번 free(double free)**
    - 동일한 청크를 두 번 이상 `free` →  
        메모리 관리자의 내부 자료구조를 망가뜨려 **취약점**이 될 수 있음.
    - 메모리 누수보다 더 위험할 수 있다는 점 강조.
5. **`malloc(0)` 호출**
    - 구현에 따라
        - `NULL`을 줄 수도 있고
        - “가짜 주소(pseudo-address)”를 줄 수도 있음.
    - 이 값을 잘못 다루면 메모리 관리 에러로 이어질 수 있어  
        → 아예 **0 크기 할당 요청이 나오지 않도록** 로직에서 막는 것이 가장 안전.

> 실무 습관:
> - `free(ptr); ptr = NULL;` 패턴 유지
> - 모든 `malloc` 계열 호출 뒤에 NULL 체크
> - 필요 없어진 포인터는 최대한 스코프를 줄여 사용

## 6. 수업에서 강조한 포인트

1. **소프트웨어 퀄리티를 높이는 세 축**
    - 시큐어 코딩(입력 검증, 메모리/정수/문자열 안전)
    - 설계 품질(객체지향 설계 원칙, 디자인 패턴)
    - 개발 방법론(XP, TDD, 코드 리뷰 등)
2. **현업/취업 관점**
    - 공공기관, 금융권 프로젝트에서는 **Secure Coding 가이드 준수**가 필수 요구사항에 걸리는 경우가 많음.
    - 이 과목 과제·프로젝트에서 “우리가 어떤 취약점을 어떻게 막기 위해 무엇을 했는지”를 정리해두면  
        → 포트폴리오/면접에서 강력한 어필 포인트가 될 수 있다고 언급.
3. **코딩 습관 세 가지**
    - **입력/파라미터 유효성 검사**
    - **변수 및 메모리 초기화**
    - **모든 함수 리턴값 확인**  
        → 이 세 가지만 꾸준히 지켜도 디펙트와 취약점 상당수를 줄일 수 있다는 메시지. (이전 코딩/시큐어코딩 강의와 연결되는 부분)